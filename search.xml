<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>焦虑的夜。</title>
      <link href="/2025/05/22/%E7%84%A6%E8%99%91%E7%9A%84%E5%A4%9C%E3%80%82/"/>
      <url>/2025/05/22/%E7%84%A6%E8%99%91%E7%9A%84%E5%A4%9C%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>我很焦虑。</p><p>看着一些小学生、初一的同学已经能做出比我还难的算法题，心里忍不住泛起一种深深的失落感。回头看看这几年走过的编程之路，满是绕远与反复——一直在努力，却始终觉得偏离了方向。</p><p>四年后就是高考，山东的竞争压力之大不言而喻。而我的成绩，却一次比一次差。无论是文化课还是编程，我都感到自己在一点点落后，仿佛看不清前方的路。</p><p>更让我无助的是，无论是在学习还是编程上，我似乎都没有一个真正的引路人。没有人告诉我该怎么学，往哪走；没有人指出我做错了什么，也没有人告诉我哪一步其实并不算失败。</p><p>于是我开始反复回顾自己的选择，怀疑自己是不是不够聪明、不够勤奋、甚至不够幸运。那些比我小的孩子，那些更早接触、更早起步的人，就像一道道亮眼的光，而我站在阴影中，被照得无处遁形。</p><p>我时常觉得，自己就像站在一条奔流不息的河边，看着别人奋力向前，而我却困在原地，寸步难行。不是不想追赶，而是脚下的土地似乎随时都可能塌陷，我根本不敢迈出下一步。</p><p>但夜深人静的时候，我也会逼自己冷静地想一想：我到底是在害怕落后，还是害怕自己根本无法赶上？我是真的走错了路，还是只是还没走到成果显现的那一步？</p><p>焦虑也许是成长的副产品。它提醒我：我在意，我不甘心，我还没放弃。</p><p>我不知道未来会变成什么样，也不知道自己还能坚持多久。但至少现在，我还想试一试——哪怕没人指引，我也想摸索出自己的路。</p><p>谁知道呢，也许某一天，当我再次回头望向此刻的自己，会想说一句：你已经做得很好了，真的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>五月月报</title>
      <link href="/2025/05/17/%E4%BA%94%E6%9C%88%E6%9C%88%E6%8A%A5/"/>
      <url>/2025/05/17/%E4%BA%94%E6%9C%88%E6%9C%88%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="成长月志算法-建站-焦虑与成长"><a class="markdownIt-Anchor" href="#成长月志算法-建站-焦虑与成长"></a> 【成长月志】算法、建站、焦虑与成长</h1><p>看了看网站，已经整整一个月没有更新了，连 SSL 证书都悄悄过期了。这段时间，我到底在忙些什么？</p><hr /><h2 id="一-刷题进度与学习状态"><a class="markdownIt-Anchor" href="#一-刷题进度与学习状态"></a> 一、刷题进度与学习状态</h2><h3 id="算法类"><a class="markdownIt-Anchor" href="#算法类"></a> 算法类</h3><p>最近在洛谷持续刷题，目前累计通过了 112 道题目。</p><p>其中：</p><ul><li>入门：86 题</li><li>普及−：23 题</li><li>普及/提高−：3 题（包括第一次 AC 的 P1205）</li></ul><p>刷题过程中，《算法竞赛入门经典》的一些题让我抓狂得快要怀疑人生，于是我转向口碑不错的《深入浅出程序设计竞赛》寻求“救赎”。目前刚学到第二部分算法——<strong>排序章节</strong>，讲得确实比我想象中更清晰易懂。</p><p>此外，我还参加了 <a href="https://www.luogu.com.cn/contest/245718">【LGR-226-Div.4】洛谷入门赛 #35</a>，最终排名 <strong>518 名</strong>，感觉还能接受，但也暴露了不少薄弱环节。</p><h3 id="学业"><a class="markdownIt-Anchor" href="#学业"></a> 学业</h3><p>地生一模，地理校第3，生物第一，总分校第一、县第五。</p><p>其他的没什么好说的。</p><hr /><h2 id="二-技能提升与项目积累"><a class="markdownIt-Anchor" href="#二-技能提升与项目积累"></a> 二、技能提升与项目积累</h2><p>除了算法，我也在慢慢完善一些个人积累：</p><h3 id="github-整理刷题代码"><a class="markdownIt-Anchor" href="#github-整理刷题代码"></a> GitHub 整理刷题代码</h3><p>我在 GitHub 上新建了一个代码库，用来记录我在洛谷刷过的题：</p><p>👉 <a href="https://github.com/LINMOH/algo_code">algo_code 仓库</a></p><p>同时也开始打理 GitHub 主页，探索 Markdown 的高级用法：</p><p>👉 <a href="https://github.com/LINMOH">我的 GitHub 主页</a></p><hr /><h2 id="三-建站从兴趣出发的小尝试"><a class="markdownIt-Anchor" href="#三-建站从兴趣出发的小尝试"></a> 三、建站：从兴趣出发的小尝试</h2><p>我重新拾起了建站这个兴趣，做了一些看似“离谱”、实则有自我风格的项目：</p><ul><li><strong>波奇酱非官方同人页</strong>：<a href="https://boochi.fans">boochi.fans</a></li><li>GitHub 仓库地址：<a href="https://github.com/LINMOH/boochi.fans">boochi.fans 仓库</a></li></ul><p>同时，我还注册了一堆脑洞清奇的域名：</p><ul><li><a href="http://bailan.top">bailan.top</a></li><li><a href="http://boochi.fans">boochi.fans</a></li><li><s><a href="http://xn--8mr985eba830aiye.xyz">玩原神玩的.xyz</a> → 跳转到学校官网</s></li><li><a href="http://no.neijuan.fun">no.neijuan.fun</a>（来自域名 neijuan.fun）</li><li><a href="http://pingyinshigao.icu">pingyinshigao.icu</a></li></ul><p>这些可能现在还“没用”，但对我来说是一种“试错式探索” —— 在技术与兴趣之间寻找乐趣和平衡。</p><hr /><h2 id="四-心态波动与自我调整"><a class="markdownIt-Anchor" href="#四-心态波动与自我调整"></a> 四、心态波动与自我调整</h2><p>坦白讲，这段时间我有些焦虑。</p><p>看着一些小学、初一的同学在洛谷上做出比我更高难度的题，甚至已经在 CSP-J 拿奖，我不止一次怀疑自己是否起步太晚，是否天赋不够。</p><p>但转念一想：<strong>别人强，只能说明他们开始得早，而我也在进步。</strong></p><p>焦虑说明我在乎，进步说明我没放弃。与其沉溺比较，不如专注成长。只要今天的我强于昨天，那就是值得骄傲的成绩。<strong>真正重要的是：走自己的路，走稳、走远。</strong></p><p><s>毕竟凉先辈说过：</s><br /><img src="https://s1.imagehub.cc/images/2025/05/17/c6e6467d180acf20e675339e9e438027.webp" alt="一旦舍弃了个性，就跟死去了没区别" /></p><hr /><h2 id="五-未来计划与行动方向"><a class="markdownIt-Anchor" href="#五-未来计划与行动方向"></a> 五、未来计划与行动方向</h2><p>接下来，我打算：</p><ul><li><strong>每周刷题目标</strong>：AC 至少 15 道题，其中包含 ≥2 道 <code>提高−</code> 或更高难度；</li><li><strong>博客更新</strong>：力争每月更新不少于两篇；</li><li><strong>CSP-J 初赛目标</strong>：9 月前系统整理知识点 + 做两轮模拟练习；</li><li><strong>项目方向</strong>：继续完善 boochi.fans，同步开发移动端适配，争取做一个真正可用的“兴趣展示站”。</li><li>考虑就业的话，可能还要学 Golang，具体学习时间放在 CSP-J 复赛以后吧。</li><li>想起初一时我的英语基本每次都会进入县前十，或许值得再试着夺回这份荣光？</li></ul><hr /><h2 id="六-学习之外的生活碎片"><a class="markdownIt-Anchor" href="#六-学习之外的生活碎片"></a> 六、学习之外的生活碎片</h2><p>校科技文化节两个一等奖（其实没什么）</p><ol><li><strong>科普知识讲解</strong>：<a href="https://www.bilibili.com/video/BV1y25bzyErA">视频已发在B站</a>；</li><li><strong>部分排序、查找算法可视化</strong>：未来会在 GitHub 上开源。</li></ol><p>题外话：</p><p>发布了<a href="https://www.bilibili.com/video/BV1y25bzyErA">科普讲解视频</a>，万万没想到<a href="https://space.bilibili.com/1648756265">@ydjysngs</a>还给我充了电！属实是受宠若惊。</p><hr /><p>以后每月中旬我都会写这样的小结。</p><p>下个月此时，希望能在「GitHub提交日历」上看到更密集的绿色方块，在洛谷「难易度统计」里解锁新的难度标签。继续向前走吧，哪怕步子小一点，只要不停下脚步。</p>]]></content>
      
      
      <categories>
          
          <category> 成长月志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一节课讲义：认识 C++ 输入输出与基本变量类型</title>
      <link href="/2025/04/25/class1/"/>
      <url>/2025/04/25/class1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一节课讲义认识-c-输入输出与基本变量类型"><a class="markdownIt-Anchor" href="#第一节课讲义认识-c-输入输出与基本变量类型"></a> 第一节课讲义：认识 C++ 输入输出与基本变量类型</h1><hr /><h2 id="课程目标"><a class="markdownIt-Anchor" href="#课程目标"></a> 课程目标</h2><ol><li><strong>掌握 <code>cin</code> 和 <code>cout</code> 的基本用法</strong></li><li><strong>理解 <code>int</code>、<code>float</code>、<code>char</code> 三种变量的用途</strong></li><li><strong>能编写简单的输入输出程序</strong></li></ol><hr /><h2 id="一-c-程序的基本结构"><a class="markdownIt-Anchor" href="#一-c-程序的基本结构"></a> 一、C++ 程序的基本结构</h2><h3 id="11-代码框架"><a class="markdownIt-Anchor" href="#11-代码框架"></a> 1.1 代码框架</h3><p>所有 C++ 程序都从 <code>main</code> 函数开始执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 引入输入输出库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;         <span class="comment">// 程序入口</span></span><br><span class="line">    <span class="comment">// 你的代码写在这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">// 程序结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>#include &lt;iostream&gt;</code></strong>：提供 <code>cin</code> 和 <code>cout</code> 功能。</li><li><strong><code>using namespace std;</code></strong>：避免重复写 <code>std::cout</code>，直接使用 <code>cout</code>。</li></ul><hr /><h2 id="二-输出内容cout-的用法"><a class="markdownIt-Anchor" href="#二-输出内容cout-的用法"></a> 二、输出内容：<code>cout</code> 的用法</h2><h3 id="21-输出文本与变量"><a class="markdownIt-Anchor" href="#21-输出文本与变量"></a> 2.1 输出文本与变量</h3><ul><li><strong>语法</strong>：<code>cout &lt;&lt; 内容1 &lt;&lt; 内容2 &lt;&lt; endl;</code></li><li><strong>示例</strong>：输出 “Hello, World!”</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;  <span class="comment">// endl 表示换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong>：输出你的名字</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;我的名字是：小蓝&quot;</span> &lt;&lt; endl;  <span class="comment">// 将 &quot;小蓝&quot; 改为你的名字</span></span><br></pre></td></tr></table></figure><h3 id="22-输出多个内容"><a class="markdownIt-Anchor" href="#22-输出多个内容"></a> 2.2 输出多个内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我今年&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出结果：我今年10岁！</span></span><br></pre></td></tr></table></figure><hr /><h2 id="三-输入内容cin-的用法"><a class="markdownIt-Anchor" href="#三-输入内容cin-的用法"></a> 三、输入内容：<code>cin</code> 的用法</h2><h3 id="31-基本输入操作"><a class="markdownIt-Anchor" href="#31-基本输入操作"></a> 3.1 基本输入操作</h3><ul><li><strong>语法</strong>：<code>cin &gt;&gt; 变量;</code></li><li><strong>示例</strong>：输入年龄并输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> age;                      <span class="comment">// 声明变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入年龄：&quot;</span>;       <span class="comment">// 提示用户输入</span></span><br><span class="line">    cin &gt;&gt; age;                   <span class="comment">// 读取输入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你的年龄是：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-输入不同类型的数据"><a class="markdownIt-Anchor" href="#32-输入不同类型的数据"></a> 3.2 输入不同类型的数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> height;</span><br><span class="line"><span class="type">char</span> initial;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入身高（米）：&quot;</span>;</span><br><span class="line">cin &gt;&gt; height;                   <span class="comment">// 输入小数，如 1.75</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入姓名首字母：&quot;</span>;</span><br><span class="line">cin &gt;&gt; initial;                  <span class="comment">// 输入单个字符，如 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><hr /><h2 id="四-变量的基本类型"><a class="markdownIt-Anchor" href="#四-变量的基本类型"></a> 四、变量的基本类型</h2><h3 id="41-变量的作用"><a class="markdownIt-Anchor" href="#41-变量的作用"></a> 4.1 变量的作用</h3><ul><li><strong>存储数据</strong>：像盒子一样保存程序中需要的数据（如数字、文字）。</li></ul><h3 id="42-常用变量类型"><a class="markdownIt-Anchor" href="#42-常用变量类型"></a> 4.2 常用变量类型</h3><table><thead><tr><th>类型</th><th>用途</th><th>示例</th><th>注意事项</th></tr></thead><tbody><tr><td><code>int</code></td><td>存储整数</td><td><code>int age = 15;</code></td><td>不能存储小数</td></tr><tr><td><code>float</code></td><td>存储小数</td><td><code>float pi = 3.14;</code></td><td>精度较低，适合一般计算</td></tr><tr><td><code>char</code></td><td>存储单个字符</td><td><code>char grade = 'A';</code></td><td>必须用单引号 <code>' '</code></td></tr></tbody></table><h3 id="43-变量的声明与赋值"><a class="markdownIt-Anchor" href="#43-变量的声明与赋值"></a> 4.3 变量的声明与赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score;        <span class="comment">// 声明一个整数变量</span></span><br><span class="line">score = <span class="number">90</span>;       <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> price = <span class="number">19.99</span>;  <span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="type">char</span> symbol = <span class="string">&#x27;$&#x27;</span>; </span><br></pre></td></tr></table></figure><hr /><h2 id="五-综合练习"><a class="markdownIt-Anchor" href="#五-综合练习"></a> 五、综合练习</h2><h3 id="51-任务输入个人信息并输出"><a class="markdownIt-Anchor" href="#51-任务输入个人信息并输出"></a> 5.1 任务：输入个人信息并输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 必须包含此头文件才能使用 string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的年龄：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; age;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的身高（米）：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; height;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;===== 个人信息 =====&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;身高：&quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="六-常见错误与注意事项"><a class="markdownIt-Anchor" href="#六-常见错误与注意事项"></a> 六、常见错误与注意事项</h2><ol><li><p><strong>未包含头文件</strong></p><ul><li>错误：<code>cout was not declared</code></li><li>解决：添加 <code>#include &lt;iostream&gt;</code> 和 <code>using namespace std;</code></li></ul></li><li><p><strong>变量未声明直接使用</strong></p><ul><li>错误：<code>age was not declared</code></li><li>解决：使用变量前必须先声明，如 <code>int age;</code></li></ul></li><li><p><strong>错误使用引号</strong></p><ul><li>错误：<code>char c = &quot;A&quot;;</code>（双引号）</li><li>正确：<code>char c = 'A';</code>（单引号）</li></ul></li></ol><hr /><h2 id="课后任务"><a class="markdownIt-Anchor" href="#课后任务"></a> 课后任务</h2><h3 id="必做题b3648-你几岁了"><a class="markdownIt-Anchor" href="#必做题b3648-你几岁了"></a> 必做题：B3648 你几岁了</h3><p><strong>要求</strong>：输入年龄 <code>x</code>，输出 <code>I am x years old.</code>。</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am 3 years old.</span><br></pre></td></tr></table></figure><hr /><h3 id="选做题b2025-输出字符菱形"><a class="markdownIt-Anchor" href="#选做题b2025-输出字符菱形"></a> 选做题：B2025 输出字符菱形</h3><p><strong>要求</strong>：用 <code>*</code> 输出一个对角线长为 5 的菱形。</p><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：使用多个 <code>cout</code> 控制空格和 <code>*</code> 的数量。</p><hr /><p><strong>下节课预告</strong>：学习运算符（加减乘除）和条件语句（if）！</p>]]></content>
      
      
      <categories>
          
          <category> 教学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P5725 【深基4.习8】求三角形</title>
      <link href="/2025/04/25/p5725/"/>
      <url>/2025/04/25/p5725/</url>
      
        <content type="html"><![CDATA[<h1 id="p5725-深基4习8求三角形"><a class="markdownIt-Anchor" href="#p5725-深基4习8求三角形"></a> P5725 【深基4.习8】求三角形</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>模仿例题，打印出不同方向的正方形，然后打印三角形矩阵。中间有个空行。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>输入矩阵的规模，不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>输出矩形和正方形</p><h2 id="输入输出样例-1"><a class="markdownIt-Anchor" href="#输入输出样例-1"></a> 输入输出样例 #1</h2><h3 id="输入-1"><a class="markdownIt-Anchor" href="#输入-1"></a> 输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a class="markdownIt-Anchor" href="#输出-1"></a> 输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">01020304</span><br><span class="line">05060708</span><br><span class="line">09101112</span><br><span class="line">13141516</span><br><span class="line"></span><br><span class="line">      01</span><br><span class="line">    0203</span><br><span class="line">  040506</span><br><span class="line">07080910</span><br></pre></td></tr></table></figure><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= <span class="number">9</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; cnt;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; cnt;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> space = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (space &lt; <span class="number">10</span> - <span class="number">2</span> * (a + <span class="number">1</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            space++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt;= a; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">9</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; count;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 WA 了</p><p>经过 debug，问题出在空格的输出上。</p><p>原本计算空格的公式为<code>10 - 2 * (a + 1)</code>，应该为<code>(n - a) * 2</code>才对。</p><h2 id="修改后的代码"><a class="markdownIt-Anchor" href="#修改后的代码"></a> 修改后的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= <span class="number">9</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; cnt;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; cnt;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= n; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> space = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (space &lt; (n - a) * <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            space++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt;= a; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">9</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; count;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC。</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排列组合</title>
      <link href="/2025/04/02/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2025/04/02/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="排列组合"><a class="markdownIt-Anchor" href="#排列组合"></a> 排列组合</h1><p>之前做 CSP-J 初赛试题总是不会做排列组合的题，现在就来补坑。</p><h2 id="阶乘"><a class="markdownIt-Anchor" href="#阶乘"></a> 阶乘</h2><p><code>n!</code>（读作“n 的阶乘”）表示从<code>1</code>到<code>n</code>的所有整数的乘积，即：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>n</mi>  <mo>!</mo>  <mo>=</mo>  <mi>n</mi>  <mo>×</mo>  <mo stretchy="false">(</mo>  <mi>n</mi>  <mo>−</mo>  <mn>1</mn>  <mo stretchy="false">)</mo>  <mo>×</mo>  <mo stretchy="false">(</mo>  <mi>n</mi>  <mo>−</mo>  <mn>2</mn>  <mo stretchy="false">)</mo>  <mo>×</mo>  <mo>⋯</mo>  <mo>×</mo>  <mn>2</mn>  <mo>×</mo>  <mn>1</mn></math></p><p>并且规定：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>0</mn>  <mo>!</mo>  <mo>=</mo>  <mn>1</mn></math></p><h2 id="排列公式"><a class="markdownIt-Anchor" href="#排列公式"></a> 排列公式</h2><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo stretchy="false">(</mo>  <mi>n</mi>  <mo>,</mo>  <mi>k</mi>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mi>n</mi>      <mo>!</mo>    </mrow>    <mrow>      <mo stretchy="false">(</mo>      <mi>n</mi>      <mo>−</mo>      <mi>k</mi>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac></math></p><p><strong>排列****强调顺序</strong>，表示从<strong>n个不同元素</strong>中取出<strong>k个元素</strong>并<strong>考虑顺序</strong>的排列方式总数，即两个排列如果<strong>顺序不同</strong>就视为<strong>不同的情况</strong>。</p><p>例如：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo stretchy="false">(</mo>  <mn>5</mn>  <mo>,</mo>  <mn>3</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>!</mo>    </mrow>    <mrow>      <mo stretchy="false">(</mo>      <mn>5</mn>      <mo>−</mo>      <mn>3</mn>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>2</mn>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>×</mo>      <mn>4</mn>      <mo>×</mo>      <mn>3</mn>      <mo>×</mo>      <mn>2</mn>      <mo>×</mo>      <mn>1</mn>    </mrow>    <mrow>      <mn>2</mn>      <mo>×</mo>      <mn>1</mn>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mn>120</mn>    <mn>2</mn>  </mfrac>  <mo>=</mo>  <mn>60</mn></math></p><h2 id="组合公式"><a class="markdownIt-Anchor" href="#组合公式"></a> 组合公式</h2><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mi>n</mi>  <mo>,</mo>  <mi>k</mi>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mi>n</mi>      <mo>!</mo>    </mrow>    <mrow>      <mi>k</mi>      <mo>!</mo>      <mo stretchy="false">(</mo>      <mi>n</mi>      <mo>−</mo>      <mi>k</mi>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac></math></p><p><strong>组合数</strong>表示从<strong>n个不同元素</strong>中取出<strong>k个元素</strong>且<strong>不考虑顺序</strong>的组合方式总数，选出的结果中不关心排列的顺序，只关注“<strong>哪些元素被选中</strong>”。</p><p>例如：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>5</mn>  <mo>,</mo>  <mn>3</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>3</mn>      <mo>!</mo>      <mo stretchy="false">(</mo>      <mn>5</mn>      <mo>−</mo>      <mn>3</mn>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>3</mn>      <mo>!</mo>      <mo>×</mo>      <mn>2</mn>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>×</mo>      <mn>4</mn>      <mo>×</mo>      <mn>3</mn>      <mo>×</mo>      <mn>2</mn>      <mo>×</mo>      <mn>1</mn>    </mrow>    <mrow>      <mo stretchy="false">(</mo>      <mn>3</mn>      <mo>×</mo>      <mn>2</mn>      <mo>×</mo>      <mn>1</mn>      <mo stretchy="false">)</mo>      <mo stretchy="false">(</mo>      <mn>2</mn>      <mo>×</mo>      <mn>1</mn>      <mo stretchy="false">)</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mn>120</mn>    <mn>12</mn>  </mfrac>  <mo>=</mo>  <mn>10</mn></math></p><h2 id="重复元素排列公式"><a class="markdownIt-Anchor" href="#重复元素排列公式"></a> 重复元素排列公式</h2><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo>=</mo>  <mfrac>    <mrow>      <mi>n</mi>      <mo>!</mo>    </mrow>    <mrow>      <msub>        <mi>a</mi>        <mn>1</mn>      </msub>      <mo>!</mo>      <mo>×</mo>      <msub>        <mi>a</mi>        <mn>2</mn>      </msub>      <mo>!</mo>      <mo>×</mo>      <mo>⋯</mo>      <mo>×</mo>      <msub>        <mi>a</mi>        <mi>k</mi>      </msub>      <mo>!</mo>    </mrow>  </mfrac></math></p><p>当元素中有重复时（如字母AABBC），全排列数需除以重复元素内部的排列数。</p><p>例如：排列AABBC，总方式为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo>=</mo>  <mfrac>    <mrow>      <mn>5</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>2</mn>      <mo>!</mo>      <mo>×</mo>      <mn>2</mn>      <mo>!</mo>      <mo>×</mo>      <mn>1</mn>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mn>120</mn>    <mn>4</mn>  </mfrac>  <mo>=</mo>  <mn>30</mn></math></p><p>排列AABBC：5个位置中，2个A、2个B、1个C。</p><h2 id="相邻问题捆绑法"><a class="markdownIt-Anchor" href="#相邻问题捆绑法"></a> 相邻问题（捆绑法）</h2><p>当某几个元素必须相邻时，我们可以将它们看作是一个“大块”（一个整体），然后计算这些“大块”与其他元素的排列数。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <msub>    <mi>P</mi>    <mrow>      <mtext>相邻</mtext>    </mrow>  </msub>  <mo>=</mo>  <mo stretchy="false">(</mo>  <mi>n</mi>  <mo>−</mo>  <mi>k</mi>  <mo>+</mo>  <mn>1</mn>  <mo stretchy="false">)</mo>  <mo>!</mo>  <mo>×</mo>  <mi>k</mi>  <mo>!</mo></math></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>5 个人 A、B、C、D、E 排队，其中 A 和 B 必须相邻，问有多少种不同的排法？</p><h4 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h4><ol><li>把 A 和 B 视为一个整体（AB），那么就相当于 4 个单元（AB、C、D、E）。</li><li>对这 4 个单元进行全排列：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>4</mn>  <mo>!</mo>  <mo>=</mo>  <mn>24</mn></math></li><li>AB 内部也可以交换位置（AB 或 BA），即：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>2</mn>  <mo>!</mo>  <mo>=</mo>  <mn>2</mn></math></li><li>总排列数：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>4</mn>  <mo>!</mo>  <mo>×</mo>  <mn>2</mn>  <mo>!</mo>  <mo>=</mo>  <mn>24</mn>  <mo>×</mo>  <mn>2</mn>  <mo>=</mo>  <mn>48</mn></math></li></ol><p>所以总共有 <code>48 种</code> 排列方式。</p><h2 id="不相邻问题插空法"><a class="markdownIt-Anchor" href="#不相邻问题插空法"></a> 不相邻问题（插空法）</h2><p>在排列组合问题中，如果题目要求某些元素必须 不相邻，我们可以使用插空法（Slot Method） 来解决。</p><p>当某些元素必须不相邻时，我们可以先安排其他元素，然后再把这些特殊元素插入剩余的空隙中，确保它们不会相邻。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mtext>不相邻排列数</mtext>  <mo>=</mo>  <mi>m</mi>  <mo>!</mo>  <mo>×</mo>  <mi>C</mi>  <mo stretchy="false">(</mo>  <mi>m</mi>  <mo>+</mo>  <mn>1</mn>  <mo>,</mo>  <mi>n</mi>  <mo stretchy="false">)</mo>  <mo>×</mo>  <mi>n</mi>  <mo>!</mo></math></p><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><p>5 个人 A、B、C、D、E 排队，其中 X 和 Y 必须不相邻，问有多少种不同的排法？</p><h4 id="解法-2"><a class="markdownIt-Anchor" href="#解法-2"></a> 解法</h4><ol><li>先安排 5 个人 A、B、C、D、E，总排列数：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>5</mn>  <mo>!</mo>  <mo>=</mo>  <mn>120</mn></math></li><li>形成 6 个空位（前后+中间）：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mo>−</mo>  <mi>A</mi>  <mo>−</mo>  <mi>B</mi>  <mo>−</mo>  <mi>C</mi>  <mo>−</mo>  <mi>D</mi>  <mo>−</mo>  <mi>E</mi>  <mo>−</mo></math></li><li>从这 6 个空位中选 2 个放 X 和 Y：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>6</mn>  <mo>,</mo>  <mn>2</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mn>6</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>2</mn>      <mo>!</mo>      <mo stretchy="false">(</mo>      <mn>6</mn>      <mo>−</mo>      <mn>2</mn>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>6</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>2</mn>      <mo>!</mo>      <mn>4</mn>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mfrac>    <mrow>      <mn>6</mn>      <mo>×</mo>      <mn>5</mn>    </mrow>    <mn>2</mn>  </mfrac>  <mo>=</mo>  <mn>15</mn></math></li><li>X 和 Y 在选定的 2 个位置上自由排列：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>2</mn>  <mo>!</mo>  <mo>=</mo>  <mn>2</mn></math></li><li>最终排列数：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>5</mn>  <mo>!</mo>  <mo>×</mo>  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>6</mn>  <mo>,</mo>  <mn>2</mn>  <mo stretchy="false">)</mo>  <mo>×</mo>  <mn>2</mn>  <mo>!</mo>  <mo>=</mo>  <mn>120</mn>  <mo>×</mo>  <mn>15</mn>  <mo>×</mo>  <mn>2</mn>  <mo>=</mo>  <mn>3600</mn></math></li></ol><h2 id="至少至多问题补集法"><a class="markdownIt-Anchor" href="#至少至多问题补集法"></a> 至少/至多问题（补集法）</h2><p>如果我们要求某种情况至少/至多出现多少次，可以先求 总情况数，再减去 不符合要求的情况，即：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mo>符合要求的情况数=总情况数</mo>  <mo>−</mo>  <mo>不符合的情况数</mo></math></p><p>补集法通常用于：</p><ol><li>至少发生 X 次的情况</li><li>至多发生 X 次的情况</li></ol><h3 id="公式总结"><a class="markdownIt-Anchor" href="#公式总结"></a> 公式总结</h3><p>对于时间 A：</p><ul><li>至少发生 X 次：</li></ul><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo stretchy="false">(</mo>  <mo>至少</mo>  <mi>X</mi>  <mo stretchy="false">)</mo>  <mo>=总情况数</mo>  <mo>−</mo>  <mi>P</mi>  <mo stretchy="false">(</mo>  <mo>少于</mo>  <mi>X</mi>  <mo stretchy="false">)</mo></math></p><ul><li>至多发生 X 次：</li></ul><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>P</mi>  <mo stretchy="false">(</mo>  <mo>至多</mo>  <mi>X</mi>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mi>P</mi>  <mo stretchy="false">(</mo>  <mn>0</mn>  <mo>次</mo>  <mo stretchy="false">)</mo>  <mo>+</mo>  <mi>P</mi>  <mo stretchy="false">(</mo>  <mn>1</mn>  <mo>次</mo>  <mo stretchy="false">)</mo>  <mo>+</mo>  <mo>⋯</mo>  <mo>+</mo>  <mi>P</mi>  <mo stretchy="false">(</mo>  <mi>X</mi>  <mo>次</mo>  <mo stretchy="false">)</mo></math></p><h3 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h3><p>从 10 个人中选 5 个人，要求至少有 2 名女生，问有多少种选法？</p><h4 id="解法-3"><a class="markdownIt-Anchor" href="#解法-3"></a> 解法</h4><ol><li>求总的选法（不考虑性别）：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>10</mn>  <mo>,</mo>  <mn>5</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mn>10</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>5</mn>      <mo>!</mo>      <mo stretchy="false">(</mo>      <mn>10</mn>      <mo>−</mo>      <mn>5</mn>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mn>252</mn></math></li><li>求不符合要求的情况（女生少于 2 人）：<ul><li>0 名女生（即全是男生）：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>6</mn>  <mo>,</mo>  <mn>5</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mfrac>    <mrow>      <mn>6</mn>      <mo>!</mo>    </mrow>    <mrow>      <mn>5</mn>      <mo>!</mo>      <mo stretchy="false">(</mo>      <mn>6</mn>      <mo>−</mo>      <mn>5</mn>      <mo stretchy="false">)</mo>      <mo>!</mo>    </mrow>  </mfrac>  <mo>=</mo>  <mn>6</mn></math></li><li>1 名女生（其余全是男生）：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>4</mn>  <mo>,</mo>  <mn>1</mn>  <mo stretchy="false">)</mo>  <mo>×</mo>  <mi>C</mi>  <mo stretchy="false">(</mo>  <mn>6</mn>  <mo>,</mo>  <mn>4</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mn>4</mn>  <mo>×</mo>  <mn>15</mn>  <mo>=</mo>  <mn>60</mn></math></li></ul></li><li>符合要求的选法：<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">  <mn>252</mn>  <mo>−</mo>  <mo stretchy="false">(</mo>  <mn>6</mn>  <mo>+</mo>  <mn>60</mn>  <mo stretchy="false">)</mo>  <mo>=</mo>  <mn>186</mn></math></li></ol><p>所以至少选 2 名女生的选法有 186 种。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学的数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【补】搜索</title>
      <link href="/2025/03/29/%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/29/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>在这里，汇集了<strong>搜索算法</strong>，包括线性查找、二分查找等。</p><h2 id="线性查找linear-search"><a class="markdownIt-Anchor" href="#线性查找linear-search"></a> 线性查找（Linear Search）</h2><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = i + <span class="number">1</span>;  <span class="comment">// 初始化数组，1~10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> find;</span><br><span class="line">    cin &gt;&gt; find;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == find)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i;  <span class="comment">// 输出找到的索引</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found&quot;</span>;  <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法解析"><a class="markdownIt-Anchor" href="#算法解析"></a> 算法解析</h3><p>这是最基本的查找算法，也是最简单的一种。</p><ol><li>遍历数组<ul><li>for (int i = 0; i &lt; 10; i++)，依次检查 nums[i]</li></ul></li><li>判断是否匹配<ul><li>if (nums[i] == find)，如果找到目标值，就输出索引 i</li></ul></li><li>提前返回<ul><li>return 0; 避免多余的遍历，提高效率</li></ul></li><li>未找到时输出 “Not found”<ul><li>遍历结束仍然没找到目标值，则打印 “Not found”</li></ul></li></ol><p>时间复杂度为 O(n)，适用于无序数组，或小规模数据</p><hr /><h2 id="二分查找binary-search"><a class="markdownIt-Anchor" href="#二分查找binary-search"></a> 二分查找（Binary Search）</h2><h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> find = <span class="number">0</span>;                      <span class="comment">// 要查找的元素</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">9</span>;           <span class="comment">// 元素下标</span></span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;                       <span class="comment">// 元素下标</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; find;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; find)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 要找的元素在中点左边</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; find)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要找的元素在中点左边</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == find)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法解析-2"><a class="markdownIt-Anchor" href="#算法解析-2"></a> 算法解析</h3><ol><li>初始化<ul><li>nums 数组被初始化为 {1, 2, 3, …, 10}，即 升序排列。</li><li>left = 0, right = 9，分别表示搜索范围的 左端 和 右端。</li><li>mid = (left + right) / 2，计算当前范围的 中间元素。</li></ul></li><li>查找过程<ul><li>如果 nums[mid] &gt; find，说明目标在 左半部分，所以更新 right = mid - 1。</li><li>如果 nums[mid] &lt; find，说明目标在 右半部分，所以更新 left = mid + 1。</li><li>如果 nums[mid] == find，找到目标，输出索引并终止程序。</li></ul></li><li>终止条件<ul><li>找到目标时，输出其索引并返回。</li><li>若 left &gt; right，表示搜索范围为空，目标元素不存在，输出 “Not found”。</li></ul></li></ol><h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3><p>二分查找的时间复杂度是 O(log N)，原因是：</p><ol><li>每次查找 都会把搜索范围缩小一半。</li><li>长度为 N 的数组，最多 log₂(N) 次 就能找到目标。</li></ol><h4 id="对于-n-10"><a class="markdownIt-Anchor" href="#对于-n-10"></a> 对于 N = 10：</h4><p>最多 log₂(10) ≈ 3.3 ≈ 4 次迭代。</p><h4 id="对于-n-1000000"><a class="markdownIt-Anchor" href="#对于-n-1000000"></a> 对于 n = 1,000,000：</h4><p>最多 log₂(1000000) ≈ 20 次迭代，而线性查找 O(n) 最坏要 1,000,000 次。</p><p>仅适用于<strong>有序数组</strong>，为了使用二分查找而对数组进行排序是得不偿失的。</p><hr /><h2 id="线性查找与二份查找对比"><a class="markdownIt-Anchor" href="#线性查找与二份查找对比"></a> 线性查找与二份查找对比</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>线性查找</strong></th><th><strong>二分查找</strong></th></tr></thead><tbody><tr><td><strong>数据要求</strong></td><td><strong>无序、有序都可以</strong></td><td><strong>必须有序</strong></td></tr><tr><td><strong>时间复杂度（最坏情况）</strong></td><td>O(N)</td><td>O(log N)</td></tr><tr><td><strong>小规模数据</strong></td><td><strong>快</strong></td><td>慢</td></tr><tr><td><strong>大规模数据</strong></td><td>慢</td><td><strong>快</strong></td></tr><tr><td><strong>空间复杂度</strong></td><td>O(1)</td><td>O(1)（迭代）/ O(log N)（递归）</td></tr><tr><td><strong>适用场景</strong></td><td>小数据、无序数组</td><td>大数据、有序数组</td></tr></tbody></table><table><thead><tr><th><strong>情况</strong></th><th><strong>建议使用</strong></th></tr></thead><tbody><tr><td><strong>无序数组</strong></td><td>线性查找</td></tr><tr><td><strong>小数据集（N ≤ 100）</strong></td><td>线性查找</td></tr><tr><td><strong>大数据集（N ≥ 1000）且有序</strong></td><td>二分查找</td></tr><tr><td><strong>链表存储</strong></td><td>线性查找</td></tr><tr><td><strong>频繁插入/删除数据</strong></td><td>线性查找（或哈希表）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求和符号∑</title>
      <link href="/2025/03/28/mathSunSign/"/>
      <url>/2025/03/28/mathSunSign/</url>
      
        <content type="html"><![CDATA[<h2 id="求和符号"><a class="markdownIt-Anchor" href="#求和符号"></a> 求和符号∑</h2><h3 id="1-数学中的"><a class="markdownIt-Anchor" href="#1-数学中的"></a> <strong>1. 数学中的 ∑</strong></h3><p><strong>∑</strong> 是数学中的<strong>求和符号</strong>，用于表示一系列数的累加。它的核心作用是将复杂的加法表达式简化为紧凑的形式。</p><h4 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> <strong>基本结构</strong></h4><p><svg xmlns="http://www.w3.org/2000/svg" width="7.429ex" height="6.749ex" viewBox="0 -1740.7 3283.7 2983.1" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-24-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-24-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-24-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-24-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-24-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path><path id="MJX-24-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path><path id="MJX-24-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-24-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-24-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(137.9, -1084.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-24-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-24-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1123, 0)"><use xlink:href="#MJX-24-TEX-I-1D44E"></use></g></g><g data-mml-node="TeXAtom" transform="translate(570.3, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-24-TEX-I-1D44F"></use></g></g></g><g data-mml-node="mi" transform="translate(1610.7, 0)"><use xlink:href="#MJX-24-TEX-I-1D453"></use></g><g data-mml-node="mo" transform="translate(2160.7, 0)"><use xlink:href="#MJX-24-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(2549.7, 0)"><use xlink:href="#MJX-24-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(2894.7, 0)"><use xlink:href="#MJX-24-TEX-N-29"></use></g></g></g></svg></p><ul><li><strong>下标</strong> (<code>i=a</code>)：求和变量（索引）的起始值。</li><li><strong>上标</strong> (<code>b</code>)：求和变量的终止值。</li><li><strong>表达式</strong> (<code>f(i)</code>)：被求和的项，通常与索引变量 <code>i</code> 相关。</li></ul><h4 id="数学示例"><a class="markdownIt-Anchor" href="#数学示例"></a> <strong>数学示例</strong></h4><ol><li><strong>简单累加</strong><br />计算 1 到 5 的和：</li></ol><p><svg xmlns="http://www.w3.org/2000/svg" width="29.44ex" height="6.712ex" viewBox="0 -1720.9 13012.6 2966.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-25-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-25-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-25-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-25-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-25-TEX-N-35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path id="MJX-25-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-25-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-25-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-25-TEX-N-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-25-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-25-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-25-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-25-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(545.2, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-25-TEX-N-35"></use></g></g></g><g data-mml-node="mi" transform="translate(1610.7, 0)"><use xlink:href="#MJX-25-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(2233.4, 0)"><use xlink:href="#MJX-25-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(3289.2, 0)"><use xlink:href="#MJX-25-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(4011.4, 0)"><use xlink:href="#MJX-25-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(5011.7, 0)"><use xlink:href="#MJX-25-TEX-N-32"></use></g><g data-mml-node="mo" transform="translate(5733.9, 0)"><use xlink:href="#MJX-25-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(6734.1, 0)"><use xlink:href="#MJX-25-TEX-N-33"></use></g><g data-mml-node="mo" transform="translate(7456.3, 0)"><use xlink:href="#MJX-25-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(8456.6, 0)"><use xlink:href="#MJX-25-TEX-N-34"></use></g><g data-mml-node="mo" transform="translate(9178.8, 0)"><use xlink:href="#MJX-25-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(10179, 0)"><use xlink:href="#MJX-25-TEX-N-35"></use></g><g data-mml-node="mo" transform="translate(10956.8, 0)"><use xlink:href="#MJX-25-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(12012.6, 0)"><use xlink:href="#MJX-25-TEX-N-31"></use><use xlink:href="#MJX-25-TEX-N-35" transform="translate(500, 0)"></use></g></g></g></svg></p><hr /><h3 id="看不懂怎么办"><a class="markdownIt-Anchor" href="#看不懂怎么办"></a> <strong>看不懂，怎么办</strong></h3><p>没关系！让我们以计算机科学的思维，从代码的角度来理解 ∑。</p><h4 id="基本示例"><a class="markdownIt-Anchor" href="#基本示例"></a> <strong>基本示例</strong></h4><p><svg xmlns="http://www.w3.org/2000/svg" width="4.425ex" height="6.712ex" viewBox="0 -1720.9 1955.7 2966.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-26-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-26-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-26-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-26-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-26-TEX-N-35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-26-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-26-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-26-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-26-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(545.2, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-26-TEX-N-35"></use></g></g></g><g data-mml-node="mi" transform="translate(1610.7, 0)"><use xlink:href="#MJX-26-TEX-I-1D456"></use></g></g></g></svg></p><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    total += i</span><br></pre></td></tr></table></figure><h4 id="一般性例子"><a class="markdownIt-Anchor" href="#一般性例子"></a> <strong>一般性例子</strong></h4><p><svg xmlns="http://www.w3.org/2000/svg" width="5.506ex" height="6.354ex" viewBox="0 -1562.5 2433.6 2808.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-27-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-27-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-27-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-27-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-27-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-27-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-27-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-27-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-27-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-27-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(509.9, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-27-TEX-I-1D45B"></use></g></g></g><g data-mml-node="msub" transform="translate(1610.7, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-27-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(529, -150) scale(0.707)"><use xlink:href="#MJX-27-TEX-I-1D456"></use></g></g></g></g></svg></p><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    total += a[i]</span><br></pre></td></tr></table></figure><p><s>还是代码好理解！</s></p><hr /><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> <strong>应用场景</strong></h4><ul><li><strong>算法设计</strong>：累加操作广泛用于统计、排序、动态规划等算法。</li><li><strong>时间复杂度分析</strong>：循环中的 ∑ 符号常用于计算时间复杂度。<br />例如：双重循环的时间复杂度为：</li></ul><p><svg xmlns="http://www.w3.org/2000/svg" width="17.193ex" height="6.9ex" viewBox="0 -1717.4 7599.4 3049.6" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-28-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-28-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-28-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-28-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-28-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-28-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-28-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-28-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-28-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-28-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-28-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-28-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-28-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-28-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(509.9, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-28-TEX-I-1D45B"></use></g></g></g><g data-mml-node="munderover" transform="translate(1610.7, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-28-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(124.5, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-28-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(412, 0)"><use xlink:href="#MJX-28-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1190, 0)"><use xlink:href="#MJX-28-TEX-N-31"></use></g></g><g data-mml-node="TeXAtom" transform="translate(600, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-28-TEX-I-1D456"></use></g></g></g><g data-mml-node="mn" transform="translate(3221.3, 0)"><use xlink:href="#MJX-28-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(3999.1, 0)"><use xlink:href="#MJX-28-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(5054.9, 0)"><use xlink:href="#MJX-28-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(5817.9, 0)"><use xlink:href="#MJX-28-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(6206.9, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-28-TEX-I-1D45B"></use></g><g data-mml-node="mn" transform="translate(600, 413) scale(0.707)"><use xlink:href="#MJX-28-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(7210.4, 0)"><use xlink:href="#MJX-28-TEX-N-29"></use></g></g></g></svg></p><ul><li><strong>概率与统计</strong>：在概率论中，∑ 用于计算期望值、方差等。</li><li><strong>数据处理</strong>：如计算数组元素总和、均值或加权和。</li></ul><hr /><h3 id="3-数学与计算机科学的联系"><a class="markdownIt-Anchor" href="#3-数学与计算机科学的联系"></a> <strong>3. 数学与计算机科学的联系</strong></h3><p>可用于<strong>算法优化</strong></p><ul><li>数学中的求和公式（如等差数列求和公式）可以优化代码，避免低效的循环。<ul><li>例如，计算 1 到 n 的和时，直接使用公式 <code>n(n+1)/2</code> 比循环更高效。</li></ul></li></ul><hr /><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h3><p><strong>∑</strong> 是数学和计算机科学中表达累加操作的核心符号。在数学中，它简化了复杂的加法表达式；在编程中，它对应循环或递归逻辑。理解 ∑ 的底层原理（如索引变量、边界条件）对算法设计和数学建模至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学的数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学专栏总序</title>
      <link href="/2025/03/28/mathxu/"/>
      <url>/2025/03/28/mathxu/</url>
      
        <content type="html"><![CDATA[<h1 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h1><h3 id="当数学渣开始造轮子"><a class="markdownIt-Anchor" href="#当数学渣开始造轮子"></a> 当数学渣开始造轮子</h3><p><strong>“你要写数学专栏？！”</strong><br />——来自三位好友的夺命连问</p><p>澄清一点，这个专栏的数学，是为了计算机科学服务的，而不是为了数学，<s>毕竟我对数学可以说是到了“厌恶”的地步</s>。所以，数学的难度，不会特别高，<s>对于大佬们来说甚至是简单</s>，但会尽量涵盖和 CS 有关的数学知识。</p><p>因此，我将题目改为：</p><h1 id="为计算机科学而学习的数学知识"><a class="markdownIt-Anchor" href="#为计算机科学而学习的数学知识"></a> 为计算机科学而学习的数学知识</h1><p>作为学校著名的<s>数学渣渣</s>，这个决定确实充满“魔幻现实主义色彩”。但当我第N次被《CLRS》和《CSAPP》中跃动的Σ符号击溃时，终于意识到：<strong>计算机科学大厦的裂缝，往往始于数学地基的沉降</strong>。</p><p><s>甚至复杂度也看不懂，我都不知道我是怎么学的算法</s>。</p><p>本专栏绝非数学系的抽象漫游，而是程序员视角的生存指南：</p><p><strong>撕开数学公式的裂口，直击计算机核心算法</strong></p><p><strong>毕竟，编写这个专栏的过程，本质上是一个数学渣渣的 debug 日志——那些让我头秃三天的数学路障，都将成为你前进路上的反光警示牌。</strong></p><p>（注：本企划存活时长与读者催更力度呈正相关）</p><h1 id="特别鸣谢"><a class="markdownIt-Anchor" href="#特别鸣谢"></a> <strong>特别鸣谢</strong></h1><p><strong>@Susan_2333</strong> 的数学外挂持续在线：<a href="https://space.bilibili.com/1317044017">他的B站主页（你敢信这只是一个初中生？）</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学的数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2025/03/28/base-conversion/"/>
      <url>/2025/03/28/base-conversion/</url>
      
        <content type="html"><![CDATA[<h1 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h1><p>日常生活中我们使用<strong>十进制</strong>（0-9），但在计算机领域中，<strong>二进制</strong>（0-1）、<strong>八进制</strong>（0-7）和<strong>十六进制</strong>（0-9, A-F）更为常见。进制转换的核心是通过数学运算在不同基数（Base）之间转换数的表示形式。理解这一原理不仅是计算机科学的基础，也是编程、网络通信甚至密码学的必备技能。</p><hr /><h2 id="为什么学习进制转换"><a class="markdownIt-Anchor" href="#为什么学习进制转换"></a> 为什么学习进制转换？</h2><ol><li><p><strong>考试需求</strong><br />信息学竞赛（如CSP、NOI）中频繁出现进制转换题目。例如，2024年山东CSP-J第一轮测试中便有一道关于二进制与十六进制转换的单选题。</p></li><li><p><strong>计算机原理基础</strong><br />计算机硬件基于二进制逻辑运行，而八进制、十六进制常用于简化二进制的表示（如内存地址、机器指令）。</p></li><li><p><strong>编程实践</strong><br />编程中常需处理不同进制的数据（如Python的<code>bin()</code>、<code>hex()</code>函数，C/C++的格式化输出）。</p></li><li><p><strong>实际应用场景</strong></p><ul><li><strong>计算机系统</strong>：二进制用于硬件设计，十六进制简化调试（如内存地址显示为<code>0x1A3F</code>）。</li><li><strong>网络与编码</strong>：IPv6地址使用十六进制（如<code>2001:0db8::ff00</code>），ASCII码用十进制或十六进制表示字符。</li><li><strong>密码学</strong>：大数运算（如RSA密钥）常以十六进制存储。</li></ul></li><li><p><strong><s>装逼</s></strong></p></li></ol><hr /><h2 id="进制转换的核心原理"><a class="markdownIt-Anchor" href="#进制转换的核心原理"></a> 进制转换的核心原理</h2><h3 id="一-进制的基本概念"><a class="markdownIt-Anchor" href="#一-进制的基本概念"></a> 一、进制的基本概念</h3><ul><li><p><strong>基数（Base）</strong>：进制使用的符号数量。</p><ul><li>十进制（Base 10）：0-9</li><li>二进制（Base 2）：0-1</li><li>十六进制（Base 16）：0-9 + A-F（A=10, B=11, …, F=15）</li></ul></li><li><p><strong>权值（Positional Value）</strong><br />每一位数字的值由其位置决定，计算公式为：</p></li></ul><p><svg xmlns="http://www.w3.org/2000/svg" width="44.937ex" height="2.47ex" viewBox="0 -883.9 19862.4 1091.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-9-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-9-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-9-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-9-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-9-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path><path id="MJX-9-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-9-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-9-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-9-TEX-N-22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path><path id="MJX-9-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="836.9px" font-family="serif">数</text><text data-variant="normal" transform="translate(837.3, 0) matrix(1 0 0 -1 0 0)" font-size="836.9px" font-family="serif">值</text></g><g data-mml-node="mo" transform="translate(1951.4, 0)"><use xlink:href="#MJX-9-TEX-N-3D"></use></g><g data-mml-node="msub" transform="translate(3007.2, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(520, -150) scale(0.707)"><use xlink:href="#MJX-9-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(4223.7, 0)"><use xlink:href="#MJX-9-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(5223.9, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D435"></use></g><g data-mml-node="mi" transform="translate(759, 413) scale(0.707)"><use xlink:href="#MJX-9-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(6679.4, 0)"><use xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="msub" transform="translate(7679.6, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D451"></use></g><g data-mml-node="TeXAtom" transform="translate(520, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600, 0)"><use xlink:href="#MJX-9-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1378, 0)"><use xlink:href="#MJX-9-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(9799.8, 0)"><use xlink:href="#MJX-9-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(10800, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D435"></use></g><g data-mml-node="TeXAtom" transform="translate(759, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600, 0)"><use xlink:href="#MJX-9-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1378, 0)"><use xlink:href="#MJX-9-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(13159.2, 0)"><use xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(14159.4, 0)"><use xlink:href="#MJX-9-TEX-N-22EF"></use></g><g data-mml-node="mo" transform="translate(15553.6, 0)"><use xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="msub" transform="translate(16553.8, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D451"></use></g><g data-mml-node="mn" transform="translate(520, -150) scale(0.707)"><use xlink:href="#MJX-9-TEX-N-30"></use></g></g><g data-mml-node="mo" transform="translate(17699.6, 0)"><use xlink:href="#MJX-9-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(18699.8, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-9-TEX-I-1D435"></use></g><g data-mml-node="mn" transform="translate(759, 413) scale(0.707)"><use xlink:href="#MJX-9-TEX-N-30"></use></g></g></g></g></svg></p><p>例如，十进制数<code>123</code>可分解为：</p><p><svg xmlns="http://www.w3.org/2000/svg" width="33.159ex" height="2.185ex" viewBox="0 -883.9 14656.4 965.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-10-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-10-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-10-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-10-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-10-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-10-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-10-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><use xlink:href="#MJX-10-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(722.2, 0)"><use xlink:href="#MJX-10-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(1722.4, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-10-TEX-N-31"></use><use xlink:href="#MJX-10-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mn" transform="translate(1000, 413) scale(0.707)"><use xlink:href="#MJX-10-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(3348.2, 0)"><use xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(4348.4, 0)"><use xlink:href="#MJX-10-TEX-N-32"></use></g><g data-mml-node="mo" transform="translate(5070.7, 0)"><use xlink:href="#MJX-10-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(6070.9, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-10-TEX-N-31"></use><use xlink:href="#MJX-10-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mn" transform="translate(1000, 413) scale(0.707)"><use xlink:href="#MJX-10-TEX-N-31"></use></g></g><g data-mml-node="mo" transform="translate(7696.7, 0)"><use xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(8696.9, 0)"><use xlink:href="#MJX-10-TEX-N-33"></use></g><g data-mml-node="mo" transform="translate(9419.1, 0)"><use xlink:href="#MJX-10-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(10419.3, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-10-TEX-N-31"></use><use xlink:href="#MJX-10-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mn" transform="translate(1000, 413) scale(0.707)"><use xlink:href="#MJX-10-TEX-N-30"></use></g></g><g data-mml-node="mo" transform="translate(12100.7, 0)"><use xlink:href="#MJX-10-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(13156.4, 0)"><use xlink:href="#MJX-10-TEX-N-31"></use><use xlink:href="#MJX-10-TEX-N-32" transform="translate(500, 0)"></use><use xlink:href="#MJX-10-TEX-N-33" transform="translate(1000, 0)"></use></g></g></g></svg></p><hr /><h3 id="二-进制转换方法"><a class="markdownIt-Anchor" href="#二-进制转换方法"></a> 二、进制转换方法</h3><h4 id="1-其他进制-十进制按权展开求和"><a class="markdownIt-Anchor" href="#1-其他进制-十进制按权展开求和"></a> 1. 其他进制 → 十进制（按权展开求和）</h4><p>将每一位数字乘以基数的幂次后相加。<br /><strong>示例</strong>：二进制<code>1011</code>转十进制</p><p><svg xmlns="http://www.w3.org/2000/svg" width="56.138ex" height="2.8ex" viewBox="0 -883.9 24813 1237.4" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-11-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-11-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-11-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-11-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-11-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-11-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-11-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-11-TEX-N-38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path id="MJX-11-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-11-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(722.2, 0)"><use xlink:href="#MJX-11-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(1722.4, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(500, 413) scale(0.707)"><use xlink:href="#MJX-11-TEX-N-33"></use></g></g><g data-mml-node="mo" transform="translate(2848.2, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(3848.4, 0)"><use xlink:href="#MJX-11-TEX-N-30"></use></g><g data-mml-node="mo" transform="translate(4570.7, 0)"><use xlink:href="#MJX-11-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(5570.9, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(500, 413) scale(0.707)"><use xlink:href="#MJX-11-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(6696.7, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(7696.9, 0)"><use xlink:href="#MJX-11-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(8419.1, 0)"><use xlink:href="#MJX-11-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(9419.3, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(500, 413) scale(0.707)"><use xlink:href="#MJX-11-TEX-N-31"></use></g></g><g data-mml-node="mo" transform="translate(10545.1, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(11545.3, 0)"><use xlink:href="#MJX-11-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(12267.5, 0)"><use xlink:href="#MJX-11-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(13267.8, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-32"></use></g><g data-mml-node="mn" transform="translate(500, 413) scale(0.707)"><use xlink:href="#MJX-11-TEX-N-30"></use></g></g><g data-mml-node="mo" transform="translate(14449.1, 0)"><use xlink:href="#MJX-11-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(15504.9, 0)"><use xlink:href="#MJX-11-TEX-N-38"></use></g><g data-mml-node="mo" transform="translate(16227.1, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(17227.3, 0)"><use xlink:href="#MJX-11-TEX-N-30"></use></g><g data-mml-node="mo" transform="translate(17949.5, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(18949.8, 0)"><use xlink:href="#MJX-11-TEX-N-32"></use></g><g data-mml-node="mo" transform="translate(19672, 0)"><use xlink:href="#MJX-11-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(20672.2, 0)"><use xlink:href="#MJX-11-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(21450, 0)"><use xlink:href="#MJX-11-TEX-N-3D"></use></g><g data-mml-node="msub" transform="translate(22505.8, 0)"><g data-mml-node="mn"><use xlink:href="#MJX-11-TEX-N-31"></use><use xlink:href="#MJX-11-TEX-N-31" transform="translate(500, 0)"></use></g><g data-mml-node="TeXAtom" transform="translate(1000, -176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><use xlink:href="#MJX-11-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(389, 0)"><use xlink:href="#MJX-11-TEX-N-31"></use><use xlink:href="#MJX-11-TEX-N-30" transform="translate(500, 0)"></use></g><g data-mml-node="mo" transform="translate(1389, 0)"><use xlink:href="#MJX-11-TEX-N-29"></use></g></g></g></g></g></svg></p><h4 id="2-十进制-其他进制"><a class="markdownIt-Anchor" href="#2-十进制-其他进制"></a> 2. 十进制 → 其他进制</h4><ul><li><strong>整数部分：除基取余法</strong><br />将十进制数反复除以目标进制基数，逆序排列余数。<br /><strong>示例</strong>：十进制<code>11</code>转二进制<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  11 = 5 × 2 + 1   (余1)</span><br><span class="line">  5 = 2 × 2 + 1    (余1)</span><br><span class="line">  2 = 1 × 2 + 0    (余0)</span><br><span class="line">  1 = 0 × 2 + 1    (余1)</span><br><span class="line">  ```  </span><br><span class="line">  逆序余数得`1011`。</span><br><span class="line"></span><br><span class="line">- **小数部分：乘基取整法**  </span><br><span class="line">  将小数部分反复乘以目标进制基数，顺序记录整数部分。  </span><br><span class="line">  **示例**：十进制`0.625`转二进制  </span><br></pre></td></tr></table></figure>0.625 × 2 = 1.25 → 取整1，剩余0.25<br />0.25 × 2 = 0.5 → 取整0，剩余0.5<br />0.5 × 2 = 1.0 → 取整1，剩余0<pre class="highlight"><code class="">顺序排列得`0.101`。</code></pre></li></ul><h4 id="3-二进制-八进制十六进制"><a class="markdownIt-Anchor" href="#3-二进制-八进制十六进制"></a> 3. 二进制 ↔ 八进制/十六进制</h4><ul><li><p><strong>二进制 → 八进制</strong><br />每3位二进制为一组（从右向左，不足补零），直接转换。<br /><strong>示例</strong>：<code>101101</code> → <code>101 101</code> → <code>5 5</code> → <code>55_&#123;(8)&#125;</code>。</p></li><li><p><strong>二进制 → 十六进制</strong><br />每4位二进制为一组（从右向左，不足补零）。<br /><strong>示例</strong>：<code>1101101</code> → <code>0110 1101</code> → <code>6 D</code> → <code>6D_&#123;(16)&#125;</code>。</p></li><li><p><strong>反向转换</strong><br />将每位八进制/十六进制数展开为3/4位二进制。<br /><strong>示例</strong>：十六进制<code>A3</code> → <code>1010 0011</code> → <code>10100011</code>。</p></li></ul><hr /><h3 id="三-通用转换公式"><a class="markdownIt-Anchor" href="#三-通用转换公式"></a> 三、通用转换公式</h3><p>所有进制转换均可通过以下公式实现：</p><p><svg xmlns="http://www.w3.org/2000/svg" width="19.461ex" height="6.399ex" viewBox="0 -1562.5 8601.6 2828.3" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-23-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-23-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-23-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-23-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-23-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-23-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-23-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-23-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-23-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="836.9px" font-family="serif">数</text><text data-variant="normal" transform="translate(837.3, 0) matrix(1 0 0 -1 0 0)" font-size="836.9px" font-family="serif">值</text></g><g data-mml-node="mo" transform="translate(1951.4, 0)"><use xlink:href="#MJX-23-TEX-N-3D"></use></g><g data-mml-node="munderover" transform="translate(3007.2, 0)"><g data-mml-node="mo" transform="translate(322.8, 0)"><use xlink:href="#MJX-23-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(0, -1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-23-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-23-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(1299, 0)"><use xlink:href="#MJX-23-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(2077, 0)"><use xlink:href="#MJX-23-TEX-I-1D45A"></use></g></g><g data-mml-node="TeXAtom" transform="translate(832.6, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-23-TEX-I-1D45B"></use></g></g></g><g data-mml-node="msub" transform="translate(5263.3, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-23-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(520, -150) scale(0.707)"><use xlink:href="#MJX-23-TEX-I-1D458"></use></g></g><g data-mml-node="mo" transform="translate(6424, 0)"><use xlink:href="#MJX-23-TEX-N-D7"></use></g><g data-mml-node="msup" transform="translate(7424.2, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-23-TEX-I-1D435"></use></g><g data-mml-node="TeXAtom" transform="translate(759, 413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-23-TEX-I-1D458"></use></g></g></g></g></g></svg></p><ul><li>( B )：目标进制基数</li><li>( d_k )：第( k )位的数字</li><li>( n, m )：整数和小数部分的位数</li></ul><hr /><h2 id="总结与技巧"><a class="markdownIt-Anchor" href="#总结与技巧"></a> 总结与技巧</h2><ol><li><p><strong>快速转换口诀</strong></p><ul><li>二进制转十六进制：4位一组，查表转换。</li><li>十进制转二进制：除2取余，逆序排列。</li></ul></li><li><p><strong>编程实现</strong><br />大多数编程语言提供内置函数（如Python的<code>int(&quot;1011&quot;, 2)</code>可直接将二进制转为十进制）。</p></li><li><p><strong>避免错误</strong></p><ul><li>补零对齐：分组转换时注意位数不足需补零（如二进制<code>101</code>转八进制需补零为<code>101</code> → <code>5</code>）。</li><li>小数精度：十进制小数转其他进制时可能无限循环（如0.1转二进制为无限循环<code>0.000110011...</code>）。</li></ul></li></ol><hr /><h2 id="参考与扩展"><a class="markdownIt-Anchor" href="#参考与扩展"></a> 参考与扩展</h2><p>Bryant, Randal E., and David R. O’Hallaron. <em>Computer Systems: A Programmer’s Perspective</em>. 3rd ed., Pearson, 2016.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS 书籍推荐</title>
      <link href="/2025/03/28/books/"/>
      <url>/2025/03/28/books/</url>
      
        <content type="html"><![CDATA[<h1 id="给朋友的cs书单从入门到放弃不是"><a class="markdownIt-Anchor" href="#给朋友的cs书单从入门到放弃不是"></a> 给朋友的CS书单：从入门到放弃（不是）</h1><p>最近莫名其妙成了“CS懂王”，每天被问最多的除了“代码跑不通怎么办”，就是“该看什么书”。为了保住人设（和友谊），特此奉上我的<strong>私藏书单</strong>！声明：所有书都是我<strong>亲自读过且成功催眠</strong>的，质量有保障！</p><p><s>(其实最主要的原因是为了<a href="https://space.bilibili.com/448627526">@Susan_2333</a>而写的)</s></p><hr /><h2 id="一-新手村装备看这些不会秃头"><a class="markdownIt-Anchor" href="#一-新手村装备看这些不会秃头"></a> 一、新手村装备（看这些不会秃头）</h2><h3 id="计算机科学概论"><a class="markdownIt-Anchor" href="#计算机科学概论"></a> 📖《计算机科学概论》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/80c23e718a53327bbbe1a0e102670ed8.jpeg" alt="封面" /></p><p>看这本书的目的是对 CS 进行一个简单的了解。但可以当故事书看！很有意思，不用看的太深,厕所读物首选，看到睡着算我输。</p><h3 id="计算机科学速成课"><a class="markdownIt-Anchor" href="#计算机科学速成课"></a> 📺<a href="https://www.bilibili.com/video/BV1EW411u7th">计算机科学速成课</a></h3><p>不可否认的一点是，这不是书。但是，这个系列的视频每集只有10多分钟，从晶体管讲到神经网络，用浅显的语言讲解 CS，非常有趣。我推荐大家先看这个视频，然后再看《计算机科学概论》。</p><p><s>（虽然我只看了前3集就去追番了）</s></p><hr /><h2 id="三-python修仙指南头发可再生"><a class="markdownIt-Anchor" href="#三-python修仙指南头发可再生"></a> 三、Python修仙指南（头发可再生）</h2><h3 id="python编程从入门到实践"><a class="markdownIt-Anchor" href="#python编程从入门到实践"></a> 📖《Python编程：从入门到实践》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/0c282a9f79ea363621c388046b99817c.jpeg" alt="修仙秘籍" /></p><p>这本书是 Python 的入门书籍，内容非常丰富，适合初学者。这本书的内容比较陡峭，但是，这本书的内容非常实用，能够帮助大家提高编程水平。</p><p><s>看完就能用Python算命！我三年级就开始学了！</s></p><h3 id="笨方法学python"><a class="markdownIt-Anchor" href="#笨方法学python"></a> 📖《笨方法学Python》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/d45f9c82396113b2de34bcac17f8f7c7.jpg" alt="笨方法学 Python3" /></p><p><s>这本书我没看过，但是据说很棒（@Susan_2333也这么说）。</s><br /><s>说实话，我还是更喜欢学术性强一点的书。</s></p><hr /><h2 id="二-cの试炼秃头预警"><a class="markdownIt-Anchor" href="#二-cの试炼秃头预警"></a> 二、C++の试炼（秃头预警）</h2><h3 id="c-primer"><a class="markdownIt-Anchor" href="#c-primer"></a> 📖《C++ Primer》</h3><p>这本书是 C++ 的入门书籍，内容非常丰富，适合初学者。但是，这本书的难度较大，建议有一定编程基础的同学阅读。</p><p><s>C++界的《新华字典》，买前雄心壮志，买后防身利器！建议和编译器拜把子再看。</s></p><h3 id="c-primer-plus"><a class="markdownIt-Anchor" href="#c-primer-plus"></a> 📖《C++ Primer Plus》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/37d225390be5bf247d1bad9aaac07afa.jpeg" alt="Plus版" /></p><p>看名字也知道，这本书是 <em>C++ Primer</em> 的补充。这本书的难度较小，适合初学者。并且，这本书内容又多又杂，面面俱到，适合想要具体学习 C++ 的同学。</p><p>比楼上那本多了个&quot;Plus&quot;，价格也Plus！但确实适合萌新，当年我就是靠它写了第一个&quot;Hello World&quot;</p><h3 id="effective-c"><a class="markdownIt-Anchor" href="#effective-c"></a> <em>Effective C++</em></h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/727fc1d70ace7dcd798fd6dbae574177.jpg" alt="Effective C++" /></p><p>这本书是 C++ 的进阶书籍，内容非常丰富，适合有一定编程基础的同学阅读。这本书的内容比较难，但是，这本书的内容非常实用，能够帮助大家提高编程水平。</p><h3 id="more-effective-c"><a class="markdownIt-Anchor" href="#more-effective-c"></a> <em>More Effective C++</em></h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/00e34610de4956eb8cd7b6bdb207372c.jpg" alt="More Effective C++" /></p><p>在 <em>Effective C++</em> 的基础上进一步补充。</p><hr /><h2 id="四-算法の奥义彻底秃头"><a class="markdownIt-Anchor" href="#四-算法の奥义彻底秃头"></a> 四、算法の奥义（彻底秃头）</h2><h3 id="hello-算法"><a class="markdownIt-Anchor" href="#hello-算法"></a> 🎮《Hello 算法》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/196ec65aeb09635cfc3ea4d7b5233c64.png" alt="游戏攻略" /></p><p>这本书不同于其他的所有书籍，这本书一开始是在 Github 上开源的、社区维护的书，这也是我极为推荐这本书的原因。<br /><a href="https://github.com/krahets/hello-algo">Github 项目地址</a><br /><a href="https://www.hello-algo.com/">在线网页</a></p><h3 id="算法导论clrs"><a class="markdownIt-Anchor" href="#算法导论clrs"></a> 📚《算法导论》（CLRS）</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/146d45211ec91746b16869f7df88b534.jpg" alt="劝退经典" /></p><p>这本书是算法领域的圣经，对计算机科学几乎是起了奠定作用，这本书在很多国内外大学是作为教材的存在，内容非常丰富。这本书的内容非常陡峭，适合有编程基础的同学阅读。</p><p><strong>使用方法</strong>：</p><ol><li>拍照发朋友圈</li><li>垫显示器</li><li>真正的大佬用它来…镇宅？<br /><s>（反正我看不懂）</s></li></ol><hr /><h2 id="五-oier-acmerの信仰走向不归路"><a class="markdownIt-Anchor" href="#五-oier-acmerの信仰走向不归路"></a> 五、OIer、ACMerの信仰（走向不归路）</h2><h3 id="算法竞赛入门经典"><a class="markdownIt-Anchor" href="#算法竞赛入门经典"></a> 🏆《算法竞赛入门经典》</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/253e0ba4546faa5023ba1654b47068d7.jpg" alt="秃头圣经" /></p><p><strong>版本玄学</strong>：</p><ul><li>第一版：薄得像小抄，价格友好但内容像压缩包</li><li>第二版：厚到能防身，新增C++骚操作和「如何假装会动态规划」指南</li></ul><p><strong>食用指南</strong>：</p><ol><li>前五章刷完可解锁「代码跑得比香港记者还快」成就</li><li>动态规划章节建议搭配生发液使用</li><li>站长锐评：「看完这本书，我变秃了，也变强了（并没有）」</li></ol><p><strong>隐藏功能</strong>：</p><ul><li>拍照发朋友圈配文「又是刷题到凌晨的一天」</li><li>垫泡面时散发学霸の气息</li></ul><p>这也是站长正在看的 CS 书籍之一。</p><hr /><h2 id="六-系统大佬の修养光头强者"><a class="markdownIt-Anchor" href="#六-系统大佬の修养光头强者"></a> 六、系统大佬の修养（光头强者）</h2><h3 id="深入理解计算机系统csapp"><a class="markdownIt-Anchor" href="#深入理解计算机系统csapp"></a> 💻《深入理解计算机系统》（CSAPP）</h3><p><img src="https://s1.imagehub.cc/images/2025/03/28/c75f2a52cb56b8c3f47ca0a7bfcd3c65.jpeg" alt="强者认证" /></p><p>关于 CS 进阶的书，我只推荐这一本。说实话，这本书不难，看这本书可以学到很多！并且，和 <s>CLRS</s> 一样，这本书是作为北京大学等高校的本科、研究生教材使用的。</p><p><s>惊人的是…我能看懂！</s></p><hr /><h2 id="七-公开课の千层套路"><a class="markdownIt-Anchor" href="#七-公开课の千层套路"></a> 七、公开课の千层套路</h2><p>除了刚才提到的《计算机科学速成课》以外，还有很多值得推荐的大学公开课，这里给出课程编码。</p><p>先普及一个概念：</p><p>计算机四大名校：<strong>MIT</strong>、<strong>CMU</strong>、<strong>Stanford</strong>、<strong>UCB</strong>，也就是<strong>麻省理工</strong>、<strong>卡内基-梅隆</strong>、<strong>斯坦福</strong>、<strong>加州-伯克利</strong>。<s>其实<strong>哈佛</strong>也不错（什么叫也不错？？）</s></p><ul><li><strong>MIT</strong>：把6.824分布式系统讲了20年还在讲Raft协议（老师：我就喜欢你看不惯又学不会的样子）</li><li><strong>Stanford</strong>：CS106系列教C++，但学生都在用Python作弊（教授：I’m watching you）</li><li><strong>Harvard CS50</strong>：最像综艺的编程课，教授David发型比课程还出圈！</li><li><strong>UC Berkeley</strong>：61系列课号多到像彩票，选课比中奖还难！</li></ul><p>国内公开课？劝你别看，<s>老师都是PPT阅读器</s>。</p><h3 id="公开课推荐"><a class="markdownIt-Anchor" href="#公开课推荐"></a> 公开课推荐</h3><p>CS50 (计算机科学导论)<br />MIT6.006 (算法导论)<br />MIT 6.046J (数据结构与算法设计)<br />CS61A (计算机体系结构)<br />CS61B (计算机体系结构)<br />CS61C (计算机体系结构)<br />CS106L (C++)</p><hr /><h2 id="八-数学の诅咒秃头终极形态"><a class="markdownIt-Anchor" href="#八-数学の诅咒秃头终极形态"></a> 八、数学の诅咒（秃头终极形态）</h2><p>计算机科学依赖的数学知识有：</p><ol><li><strong>离散数学</strong></li><li>线性代数</li><li>概率论</li><li>微积分</li></ol><p>我觉得，让我这个数学渣推荐数学书实属不妥。所以，这部分内容还是交给 <a href="https://space.bilibili.com/1317044017">@Susan_2333</a> 吧。</p><p>— 【2025–3-31更新】 —</p><p><a href="https://space.bilibili.com/1317044017">@Susan_2333</a>：</p><blockquote><p>线性代数可以看《线性代数应该这样学》，巨好看。<br />微积分的话《普林斯顿微积分读本》绝对入门佳作。</p></blockquote><p><img src="https://s1.imagehub.cc/images/2025/03/31/4b7e330f5356fadbd39baedfac760930.jpeg" alt="线性代数应该这样学" /></p><p><a href="https://www.imagehub.cc/image/s29114473.IIDAlI"><img src="https://s1.imagehub.cc/images/2025/03/31/8732dd3674750f1a7a5ede4e54ace298.jpg" alt="普林斯顿微积分读本" /></a></p><hr /><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>看到这里的朋友，恭喜你收获了<strong>收藏从未停止，学习从未开始</strong>的豪华大礼包！建议立即转发给怨种朋友，要秃一起秃！👩🦲👨🦲</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈集萃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑谬误</title>
      <link href="/2025/03/17/%E9%80%BB%E8%BE%91%E8%B0%AC%E8%AF%AF/"/>
      <url>/2025/03/17/%E9%80%BB%E8%BE%91%E8%B0%AC%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑谬误"><a class="markdownIt-Anchor" href="#逻辑谬误"></a> 逻辑谬误</h1><p>班里杠精太多了！像我们这种嘴笨的内向小男生，哪怕讲得再有理，也常常被对方带偏节奏，吵不赢，怎么办？</p><p>没关系！今天我们就来学点“<strong>逻辑谬误</strong>”，让他们无话可说！</p><h2 id="什么是逻辑谬误"><a class="markdownIt-Anchor" href="#什么是逻辑谬误"></a> <strong>什么是逻辑谬误？</strong></h2><blockquote><p>不依据逻辑的议论，尤其是指论证中不符合逻辑的推论。逻辑谬误分为形式逻辑谬误与非形式逻辑谬误。非形式逻辑谬误，实质上就是前提错误谬误。</p></blockquote><h2 id="逻辑谬误的类型"><a class="markdownIt-Anchor" href="#逻辑谬误的类型"></a> 逻辑谬误的类型</h2><p>以下是针对<strong>形式逻辑谬误</strong>与<strong>非形式逻辑谬误</strong>的分类详解，包含定义、示例及反驳方法：</p><hr /><h3 id="一-形式逻辑谬误"><a class="markdownIt-Anchor" href="#一-形式逻辑谬误"></a> <strong>一、形式逻辑谬误</strong></h3><p>形式逻辑谬误是因<strong>推理结构错误</strong>导致的无效论证，常见于演绎推理（如三段论、假言推理等）。其核心问题在于逻辑形式不成立。</p><h4 id="1-否定前件谬误denying-the-antecedent"><a class="markdownIt-Anchor" href="#1-否定前件谬误denying-the-antecedent"></a> <strong>1. 否定前件谬误（Denying the Antecedent）</strong></h4><p><strong>定义</strong>：在假言命题中，错误地通过否定前件推出否定后件。<br /><strong>逻辑形式</strong>：若 P ➛ Q ，则非 P ➛ 非 Q。<br /><strong>示例</strong>：</p><ul><li>前提：“如果下雨（P），地面会湿（Q）。”</li><li>错误推理：“今天没下雨（非 P），所以地面不湿（非 Q）。”</li></ul><p><strong>反驳</strong>：</p><ul><li>指出结构漏洞：“即使不下雨，地面也可能因洒水车或水管漏水而湿。”</li></ul><hr /><h4 id="2-肯定后件谬误affirming-the-consequent"><a class="markdownIt-Anchor" href="#2-肯定后件谬误affirming-the-consequent"></a> <strong>2. 肯定后件谬误（Affirming the Consequent）</strong></h4><p><strong>定义</strong>：在假言命题中，错误地通过肯定后件推出肯定前件。<br /><strong>逻辑形式</strong>：若  P ➛ Q ，则 Q ➛ P。<br /><strong>示例</strong>：</p><ul><li>前提：“如果一个人中毒（P），他会呕吐（Q）。”</li><li>错误推理：“他呕吐了（Q），所以他中毒了（P）。”</li></ul><p><strong>反驳</strong>：</p><ul><li>列举其他可能性：“呕吐可能由食物过敏、晕车或怀孕引起，未必是中毒。”</li></ul><hr /><h4 id="3-假两难推理false-dilemma"><a class="markdownIt-Anchor" href="#3-假两难推理false-dilemma"></a> <strong>3. 假两难推理（False Dilemma）</strong></h4><p><strong>定义</strong>：将复杂问题简化为非此即彼的二元选择，忽略中间选项。<br /><strong>示例</strong>：</p><ul><li>“要么完全禁止社交媒体，要么放任虚假信息泛滥！”</li></ul><p><strong>反驳</strong>：</p><ul><li>提出中间方案：“可以加强内容审核算法或提升用户媒介素养，而非极端选择。”</li></ul><hr /><h3 id="二-非形式逻辑谬误"><a class="markdownIt-Anchor" href="#二-非形式逻辑谬误"></a> <strong>二、非形式逻辑谬误</strong></h3><p>非形式逻辑谬误是因<strong>论证内容或语境缺陷</strong>导致的错误，涉及语义模糊、证据不足或情感操控等。</p><h4 id="1-诉诸无知appeal-to-ignorance"><a class="markdownIt-Anchor" href="#1-诉诸无知appeal-to-ignorance"></a> <strong>1. 诉诸无知（Appeal to Ignorance）</strong></h4><p><strong>定义</strong>：以“无法证伪”作为“为真”的依据（或反之）。<br /><strong>示例</strong>：</p><ul><li>“科学无法解释意识起源，所以灵魂一定存在！”</li></ul><p><strong>反驳</strong>：</p><ul><li>明确举证责任：“科学未解释 ≠ 你的假设成立。需提供灵魂存在的直接证据。”</li></ul><hr /><h4 id="2-循环论证circular-reasoning"><a class="markdownIt-Anchor" href="#2-循环论证circular-reasoning"></a> <strong>2. 循环论证（Circular Reasoning）</strong></h4><p><strong>定义</strong>：结论被隐含在前提中，实质是同义重复。<br /><strong>示例</strong>：</p><ul><li>“诚实是美德，因为道德的人总是说实话。”</li></ul><p><strong>反驳</strong>：</p><ul><li>揭露循环：“你预设了‘道德的人诚实’来证明‘诚实是美德’，需独立定义道德标准。”</li></ul><hr /><h4 id="3-滑坡谬误slippery-slope"><a class="markdownIt-Anchor" href="#3-滑坡谬误slippery-slope"></a> <strong>3. 滑坡谬误（Slippery Slope）</strong></h4><p><strong>定义</strong>：假设某一行动必然引发极端后果，但缺乏合理因果链。<br /><strong>示例</strong>：</p><ul><li>“允许学生带手机，课堂秩序会崩溃，最终学校将倒闭！”</li></ul><p><strong>反驳</strong>：</p><ul><li>打断滑坡：“芬兰允许课堂用手机辅助学习，反而提升了学生参与度。”</li></ul><hr /><h4 id="4-以偏概全hasty-generalization"><a class="markdownIt-Anchor" href="#4-以偏概全hasty-generalization"></a> <strong>4. 以偏概全（Hasty Generalization）</strong></h4><p><strong>定义</strong>：基于小样本或不典型案例得出普遍结论。<br /><strong>示例</strong>：</p><ul><li>“我遇到的三个上海人都很精明，所以上海人全都精于算计。”</li></ul><p><strong>反驳</strong>：</p><ul><li>要求统计支持：“个体案例不代表群体。需人口普查或社会学研究数据。”</li></ul><hr /><h4 id="5-区群谬误ecological-fallacy"><a class="markdownIt-Anchor" href="#5-区群谬误ecological-fallacy"></a> <strong>5. 区群谬误（Ecological Fallacy）</strong></h4><p><strong>定义</strong>：将群体统计结论错误套用到个体。<br /><strong>示例</strong>：</p><ul><li>“A 省人均收入高，所以每个 A 省人都很富裕。”</li></ul><p><strong>反驳</strong>：</p><ul><li>区分群体与个体：“人均高可能因少数富豪拉高均值，多数人收入可能中等。”</li></ul><hr /><h4 id="6-诉诸类比false-analogy"><a class="markdownIt-Anchor" href="#6-诉诸类比false-analogy"></a> <strong>6. 诉诸类比（False Analogy）</strong></h4><p><strong>定义</strong>：用不恰当的类比替代逻辑论证。<br /><strong>示例</strong>：</p><ul><li>“国家如家庭，政府省钱就该像主妇削减开支一样！”</li></ul><p><strong>反驳</strong>：</p><ul><li>指出类比漏洞：“国家经济涉及货币政策、国际贸易等复杂机制，与家庭预算本质不同。”</li></ul><hr /><h4 id="7-诉诸公众bandwagon-fallacy"><a class="markdownIt-Anchor" href="#7-诉诸公众bandwagon-fallacy"></a> <strong>7. 诉诸公众（Bandwagon Fallacy）</strong></h4><p><strong>定义</strong>：以“多数人支持”作为真理标准。<br /><strong>示例</strong>：</p><ul><li>“千万人相信星座，所以星座预测一定科学！”</li></ul><p><strong>反驳</strong>：</p><ul><li>质疑流行性≠正确性：“历史上地心说也曾被广泛接受，但科学靠证据而非投票。”</li></ul><hr /><h4 id="8-诉诸主观情感appeal-to-emotion"><a class="markdownIt-Anchor" href="#8-诉诸主观情感appeal-to-emotion"></a> <strong>8. 诉诸主观情感（Appeal to Emotion）</strong></h4><p><strong>定义</strong>：用情感操控（如恐惧、怜悯）替代理性论证。<br /><strong>示例</strong>：</p><ul><li>“不支持我的提案，就是漠视贫困儿童的生命！”</li></ul><p><strong>反驳</strong>：</p><ul><li>回归理性：“提案效果需成本效益分析，例如慈善机构公开资金使用报告。”</li></ul><hr /><h4 id="9-诉诸权威appeal-to-authority"><a class="markdownIt-Anchor" href="#9-诉诸权威appeal-to-authority"></a> <strong>9. 诉诸权威（Appeal to Authority）</strong></h4><p><strong>定义</strong>：滥用权威身份作为论据，忽视领域相关性。<br /><strong>示例</strong>：</p><ul><li>“爱因斯坦信上帝，所以宗教比科学更正确！”</li></ul><p><strong>反驳</strong>：</p><ul><li>切割领域：“爱因斯坦的物理成就与神学观点无逻辑关联，需独立论证宗教合理性。”</li></ul><hr /><h4 id="10-不相干谬误red-herring"><a class="markdownIt-Anchor" href="#10-不相干谬误red-herring"></a> <strong>10. 不相干谬误（Red Herring）</strong></h4><p><strong>定义</strong>：引入无关话题转移焦点。<br /><strong>示例</strong>：</p><ul><li>A：“政府应严控污染企业。”<br />B：“经济发展更重要，难道你想回到贫困年代？”</li></ul><p><strong>反驳</strong>：</p><ul><li>拉回主线：“讨论污染治理≠反对经济，请就环保政策本身回应。”</li></ul><hr /><h4 id="11-后此谬误post-hoc-ergo-propter-hoc"><a class="markdownIt-Anchor" href="#11-后此谬误post-hoc-ergo-propter-hoc"></a> <strong>11. 后此谬误（Post Hoc Ergo Propter Hoc）</strong></h4><p><strong>定义</strong>：混淆时间先后与因果关系。<br /><strong>示例</strong>：</p><ul><li>“接种疫苗后自闭症病例增加，所以疫苗导致自闭症！”</li></ul><p><strong>反驳</strong>：</p><ul><li>要求因果证据：“二者同时发生可能纯属巧合。大规模研究显示疫苗与自闭症无关。”</li></ul><hr /><h2 id="如何系统反驳逻辑谬误"><a class="markdownIt-Anchor" href="#如何系统反驳逻辑谬误"></a> <strong>如何系统反驳逻辑谬误？</strong></h2><ol><li><strong>识别谬误类型</strong>：明确对方犯了哪种错误（如“这是滑坡谬误”）。</li><li><strong>拆解逻辑结构</strong>：针对形式谬误，指出推理形式错误；针对非形式谬误，揭露内容漏洞。</li><li><strong>提供反例或数据</strong>：用事实、统计或案例推翻片面结论。</li><li><strong>追问证据链</strong>：“你的结论如何从前提推出？是否有研究支持？”</li><li><strong>重构合理论证</strong>：提出更严谨的推理框架或替代方案。</li></ol><p>掌握这些方法，你不仅能轻松拆解杠精的诡辩，还能提升自己的批判性思维，在任何场合都能据理力争，赢得理性对话的主动权！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈集萃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P1089 津津的储蓄计划 [NOIP 2004 提高组]</title>
      <link href="/2025/03/13/P1089/"/>
      <url>/2025/03/13/P1089/</url>
      
        <content type="html"><![CDATA[<h1 id="p1089-noip-2004-提高组-津津的储蓄计划"><a class="markdownIt-Anchor" href="#p1089-noip-2004-提高组-津津的储蓄计划"></a> P1089 [NOIP 2004 提高组] 津津的储蓄计划</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn></mrow><annotation encoding="application/x-tex">300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。</p><p>为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 元或恰好 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。</p><p>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span>月初津津手中还有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>83</mn></mrow><annotation encoding="application/x-tex">83</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">3</span></span></span></span> 元，妈妈给了津津 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn></mrow><annotation encoding="application/x-tex">300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 元。津津预计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span>月的花销是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>180</mn></mrow><annotation encoding="application/x-tex">180</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">0</span></span></span></span> 元，那么她就会在妈妈那里存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 元，自己留下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>183</mn></mrow><annotation encoding="application/x-tex">183</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">3</span></span></span></span> 元。到了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 月月末，津津手中会剩下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 元钱。</p><p>津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。</p><p>现在请你根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2004</mn></mrow><annotation encoding="application/x-tex">2004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span> 年 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 月到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2004</mn></mrow><annotation encoding="application/x-tex">2004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span> 年年末，妈妈将津津平常存的钱加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 还给津津之后，津津手中会有多少钱。</p><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 行数据，每行包含一个小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>350</mn></mrow><annotation encoding="application/x-tex">350</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mord">0</span></span></span></span> 的非负整数，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 月到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 月津津的预算。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">-X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 表示出现这种情况的第一个月；否则输出到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2004</mn></mrow><annotation encoding="application/x-tex">2004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span> 年年末津津手中会有多少钱。</p><p>注意，洛谷不需要进行文件输入输出，而是标准输入输出。</p><h3 id="输入输出样例-1"><a class="markdownIt-Anchor" href="#输入输出样例-1"></a> 输入输出样例 #1</h3><h4 id="输入-1"><a class="markdownIt-Anchor" href="#输入-1"></a> 输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">290</span><br><span class="line">230</span><br><span class="line">280</span><br><span class="line">200</span><br><span class="line">300</span><br><span class="line">170</span><br><span class="line">340</span><br><span class="line">50 </span><br><span class="line">90 </span><br><span class="line">80 </span><br><span class="line">200</span><br><span class="line">60</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a class="markdownIt-Anchor" href="#输出-1"></a> 输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-7</span><br></pre></td></tr></table></figure><h3 id="输入输出样例-2"><a class="markdownIt-Anchor" href="#输入输出样例-2"></a> 输入输出样例 #2</h3><h4 id="输入-2"><a class="markdownIt-Anchor" href="#输入-2"></a> 输入 #2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">290 </span><br><span class="line">230 </span><br><span class="line">280 </span><br><span class="line">200 </span><br><span class="line">300 </span><br><span class="line">170 </span><br><span class="line">330 </span><br><span class="line">50 </span><br><span class="line">90 </span><br><span class="line">80 </span><br><span class="line">200 </span><br><span class="line">60</span><br></pre></td></tr></table></figure><h4 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出 #2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1580</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>我们可以直接套模拟，模拟每个月的操作即可。</p><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题</h2><p>我们可以写出程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成包含每个月预算的列表</span></span><br><span class="line">    <span class="type">int</span> MonthMoneys[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt;= <span class="number">11</span>; z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> MonthMoney = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; MonthMoney;</span><br><span class="line">        MonthMoneys[z] = MonthMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mother = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> LeftMoney = <span class="number">0</span>; <span class="comment">//上个月剩余的钱数</span></span><br><span class="line">    <span class="comment">//模拟每个月的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">0</span>; month &lt;= <span class="number">11</span>; month++) <span class="comment">//month 表示数组 MonthMoneys 的下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ThisMonthMoney = LeftMoney + <span class="number">300</span>; <span class="comment">//当月的钱数</span></span><br><span class="line">        <span class="keyword">if</span> (ThisMonthMoney &gt;= MonthMoneys[month])</span><br><span class="line">        &#123;</span><br><span class="line">            ThisMonthMoney -= MonthMoneys[month];</span><br><span class="line">            mother += (ThisMonthMoney / <span class="number">100</span>) * <span class="number">100</span>;</span><br><span class="line">            LeftMoney = ThisMonthMoney % <span class="number">100</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">11</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> AllMoney = mother * <span class="number">1.2</span> + LeftMoney;</span><br><span class="line">                cout &lt;&lt; AllMoney;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是提交之后，只得了60分。QAQ</p><p>经过分析后，发现代码存在以下几个问题：</p><ol><li><strong>终止条件错误</strong>：使用 if (i == 11) 来判断是否是最后一个月输出结果，但 i 变量的作用不明确，而且 i 的值实际上不会等于 11。因此最后一个月可能不会正确输出最终结果。</li><li><strong>存款计算错误</strong>：mother * 1.2 可能导致浮点数运算错误，建议改成 mother * 120 / 100 避免浮点误差。</li><li>cout &lt;&lt; AllMoney; 需要<strong>放在循环外</strong>。</li></ol><p>更改后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成包含每个月预算的列表</span></span><br><span class="line">    <span class="type">int</span> MonthMoneys[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt;= <span class="number">11</span>; z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> MonthMoney = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; MonthMoney;</span><br><span class="line">        MonthMoneys[z] = MonthMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mother = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> LeftMoney = <span class="number">0</span>; <span class="comment">// 上个月剩余的钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟每个月的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">0</span>; month &lt;= <span class="number">11</span>; month++) <span class="comment">// month 表示数组 MonthMoneys 的下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ThisMonthMoney = LeftMoney + <span class="number">300</span>; <span class="comment">// 当月的钱数</span></span><br><span class="line">        <span class="keyword">if</span> (ThisMonthMoney &gt;= MonthMoneys[month])</span><br><span class="line">        &#123;</span><br><span class="line">            ThisMonthMoney -= MonthMoneys[month];</span><br><span class="line">            mother += (ThisMonthMoney / <span class="number">100</span>) * <span class="number">100</span>; <span class="comment">// 存入整百的钱</span></span><br><span class="line">            LeftMoney = ThisMonthMoney % <span class="number">100</span>; <span class="comment">// 剩余的钱</span></span><br><span class="line"></span><br><span class="line">            i++; <span class="comment">// 记录通过的月份</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; month + <span class="number">1</span>; <span class="comment">// 预算超支，输出 -X</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算年末的钱</span></span><br><span class="line">    <span class="type">int</span> AllMoney = mother * <span class="number">120</span> / <span class="number">100</span> + LeftMoney; <span class="comment">// 避免浮点运算</span></span><br><span class="line">    cout &lt;&lt; AllMoney;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次就是 AC 代码了。</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P2669 金币 [NOIP 2015 普及组]</title>
      <link href="/2025/03/12/p2669/"/>
      <url>/2025/03/12/p2669/</url>
      
        <content type="html"><![CDATA[<h1 id="p2669-金币-noip-2015-普及组"><a class="markdownIt-Anchor" href="#p2669-金币-noip-2015-普及组"></a> P2669 金币 [NOIP 2015 普及组]</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目背景"><a class="markdownIt-Anchor" href="#题目背景"></a> 题目背景</h3><p>NOIP2015 普及组 T1</p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 天每天收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 枚金币后，骑士会在之后的连续 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 天里，每天收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 枚金币。</p><p>请计算在前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 天里，骑士一共获得了多少金币。</p><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p>一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，表示发放金币的天数。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>一个正整数，即骑士收到的金币数。</p><h3 id="输入输出样例-1"><a class="markdownIt-Anchor" href="#输入输出样例-1"></a> 输入输出样例 #1</h3><h4 id="输入-1"><a class="markdownIt-Anchor" href="#输入-1"></a> 输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a class="markdownIt-Anchor" href="#输出-1"></a> 输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="输入输出样例-2"><a class="markdownIt-Anchor" href="#输入输出样例-2"></a> 输入输出样例 #2</h3><h4 id="输入-2"><a class="markdownIt-Anchor" href="#输入-2"></a> 输入 #2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h4 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出 #2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29820</span><br></pre></td></tr></table></figure><h3 id="说明提示"><a class="markdownIt-Anchor" href="#说明提示"></a> 说明/提示</h3><p><strong>【样例 1 说明】</strong></p><p>骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">1+2+2+3+3+3=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span> 枚金币。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le k\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>我们可以采用 <strong>按层计算</strong> 的方法，在脑海里想象，每一天发的金币数可以列成以下表格：</p><p><img src="https://pic1.imgdb.cn/item/67d1913c88c538a9b5bc2770.png" alt="分析图片" title="分析图片" /></p><p>也就是说：<br />$ 每一层发的金币数 = 层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> i = c $</p><p>由此，我们写出程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> day = <span class="number">0</span>, glod = <span class="number">0</span>, tday = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= day; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">&#123;</span><br><span class="line">glod += c;</span><br><span class="line">tday ++;</span><br><span class="line"><span class="keyword">if</span> (tday == day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tday == day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; glod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美通过！</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开灯问题</title>
      <link href="/2025/03/12/%E5%BC%80%E7%81%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/12/%E5%BC%80%E7%81%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="开灯问题"><a class="markdownIt-Anchor" href="#开灯问题"></a> 开灯问题</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有n盏灯，编号为1～n。第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉的灯将被打开，开着的灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？输入n和k，输出开着的灯的编号。k≤n≤1000。</p><h3 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 6 7</span><br></pre></td></tr></table></figure><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1:开</span></span><br><span class="line"><span class="comment">    0:关</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX = n;</span><br><span class="line">    <span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt;= n - <span class="number">1</span>; z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//生成一个全是1的列表</span></span><br><span class="line">        a[z] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序当然不能运行，它存在以下问题：</p><ol><li><p>数组 a[MAX] <strong>未正确初始化</strong>，可以改用vector。</p></li><li><p>a 数组下标从 0 开始，但灯的编号从 1 开始，需要<strong>修正数组访问方式</strong>。</p></li><li><p><strong>状态翻转逻辑错误</strong>，在翻转灯的状态时，不需要额外判断 a[j] == 0 或 a[j] == 1，直接 a[j] = !a[j]; 即可。</p></li><li><p><strong>输出错误</strong>，在输出时，遍历 j 是 0 开始的，而灯的编号是 1～n，因此 cout &lt;&lt; j; 需要 +1。</p></li></ol><p>修正一下，顺便优化一下，就得到以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 用1表示灯最开始是开的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= k; i++)  <span class="comment">// 从第2个人开始操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 每 i 个倍数翻转一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = !a[j];  <span class="comment">// 翻转状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就对了！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纠错日记</title>
      <link href="/2025/03/11/%E7%BA%A0%E9%94%99%E6%97%A5%E8%AE%B0/"/>
      <url>/2025/03/11/%E7%BA%A0%E9%94%99%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="纠错日记"><a class="markdownIt-Anchor" href="#纠错日记"></a> 纠错日记</h1><p>这几天忙着配置网站，总结了一下 debug 过程中遇到的问题和排查流程：</p><ol><li><strong>检查权限</strong>：确保权限设置为 <strong>775</strong>。</li><li><strong>确认 Node.js 版本</strong>：确保版本匹配，避免兼容性问题。</li><li><strong>清理浏览器缓存</strong>：防止缓存导致的页面异常。</li><li><strong>检查域名部署</strong>：确保域名已正确解析并部署到服务器上。</li></ol><p>每一步看似简单，但往往就是这些小细节决定了最终能否顺利运行。</p>]]></content>
      
      
      <categories>
          
          <category> 建站日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++入门：浮点数 &amp; 字符型</title>
      <link href="/2025/03/10/Cpp%E5%85%A5%E9%97%A8-%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%9E%8B/"/>
      <url>/2025/03/10/Cpp%E5%85%A5%E9%97%A8-%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="c入门c入门浮点数-字符型"><a class="markdownIt-Anchor" href="#c入门c入门浮点数-字符型"></a> C<ins>入门：C</ins>入门：浮点数 &amp; 字符型</h1><p><strong>开篇暴击</strong>：为什么0.1+0.2≠0.3？为什么’A’和65竟是孪生兄弟？准备好揭开编程世界最狡诈的伪装者真面目了吗？让我们直击浮点数与字符型的灵魂深处！</p><hr /><h2 id="引言当计算机遇上连续世界"><a class="markdownIt-Anchor" href="#引言当计算机遇上连续世界"></a> 引言：当计算机遇上连续世界</h2><h3 id="浮点数的奇幻漂流"><a class="markdownIt-Anchor" href="#浮点数的奇幻漂流"></a> 浮点数的奇幻漂流</h3><p>想象用乐高积木拼出圆周率——这就是浮点数的本质！它们用有限精度逼近无限可能，就像用火柴棒拼出蒙娜丽莎的微笑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 在内存中其实是314159×10⁻⁵的二进制版本</span></span><br></pre></td></tr></table></figure><h3 id="字符的七十二变"><a class="markdownIt-Anchor" href="#字符的七十二变"></a> 字符的七十二变</h3><p>每个字符都是穿着ASCII外衣的整型间谍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;         <span class="comment">// 表面是字母</span></span><br><span class="line"><span class="type">int</span> secret = c;       <span class="comment">// 暴露真身：65</span></span><br></pre></td></tr></table></figure><hr /><h2 id="一-浮点数的量子世界"><a class="markdownIt-Anchor" href="#一-浮点数的量子世界"></a> 一、浮点数的量子世界</h2><h3 id="11-浮点三巨头对比"><a class="markdownIt-Anchor" href="#11-浮点三巨头对比"></a> 1.1 浮点三巨头对比</h3><table><thead><tr><th>类型</th><th>内存空间</th><th>有效数字</th><th>典型范围</th><th>适用场景</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>6-7位</td><td>±1.18×10⁻³⁸ ~ ±3.4×10³⁸</td><td>图形坐标</td></tr><tr><td>double</td><td>8字节</td><td>15-16位</td><td>±2.23×10⁻³⁰⁸ ~ ±1.79×10³⁰⁸</td><td>科学计算</td></tr><tr><td>long double</td><td>16字节</td><td>18-19位</td><td>±3.36×10⁻⁴⁹³² ~ ±1.18×10⁴⁹³²</td><td>高精度金融</td></tr></tbody></table><p><strong>内存结构解密</strong>（IEEE 754标准）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">符号位 [1] | 指数位 [8/11] | 尾数位 [23/52]</span><br><span class="line">就像科学计数法的二进制版：(-1)^s × 1.m × 2^(e-127)</span><br></pre></td></tr></table></figure><h3 id="12-浮点数的七大罪"><a class="markdownIt-Anchor" href="#12-浮点数的七大罪"></a> 1.2 浮点数的七大罪</h3><p><strong>精度丢失案发现场</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">0.1f</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">cout &lt;&lt; a + b;  <span class="comment">// 输出0.30000000000000004（不是笔误！）</span></span><br></pre></td></tr></table></figure><p><strong>比较浮点数的正确姿势</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; <span class="number">1e-6</span>;  <span class="comment">// 设置误差容忍度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊值禁区</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> nan = <span class="built_in">sqrt</span>(<span class="number">-1.0</span>);    <span class="comment">// NaN（非数字）</span></span><br><span class="line"><span class="type">double</span> inf = <span class="number">1.0</span> / <span class="number">0.0</span>;     <span class="comment">// ∞（无穷大）</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isnan</span>(nan)) cout &lt;&lt; <span class="string">&quot;逮到一个非法数字！&quot;</span>;</span><br></pre></td></tr></table></figure><hr /><h2 id="二-字符的变形记"><a class="markdownIt-Anchor" href="#二-字符的变形记"></a> 二、字符的变形记</h2><h3 id="21-ascii编码128个角色的舞台"><a class="markdownIt-Anchor" href="#21-ascii编码128个角色的舞台"></a> 2.1 ASCII编码：128个角色的舞台</h3><p><strong>经典角色速查</strong>：</p><ul><li>0~31：控制字符（如’\n’换行、'\t’制表）</li><li>32~126：可打印字符（空格到波浪号）</li><li>127：DEL键</li><li>128~255：扩展ASCII（因系统而异）</li></ul><p><strong>字符整型互换术</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">67</span>;            <span class="comment">// 67 → &#x27;C&#x27;</span></span><br><span class="line"><span class="type">int</span> ascii = <span class="string">&#x27;Z&#x27;</span>;        <span class="comment">// 90</span></span><br><span class="line">cout &lt;&lt; (<span class="type">char</span>)(ascii<span class="number">+2</span>) <span class="comment">// 输出&#x27;\&#x27;（92对应的字符）</span></span><br></pre></td></tr></table></figure><h3 id="22-转义字符键盘上的暗语者"><a class="markdownIt-Anchor" href="#22-转义字符键盘上的暗语者"></a> 2.2 转义字符：键盘上的暗语者</h3><p><strong>常用转义符黑话表</strong>：</p><ul><li><code>\n</code>：换行（newline）</li><li><code>\t</code>：水平制表</li><li><code>\\</code>：反斜杠本尊</li><li><code>\&quot;</code>：在字符串中显示引号</li><li><code>\x41</code>：十六进制表示（‘A’）</li></ul><p><strong>危险操作示范</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> danger = <span class="string">&#x27;\61&#x27;</span>;    <span class="comment">// 八进制61=十进制49 → &#x27;1&#x27;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\v正在格式化硬盘...&quot;</span>; <span class="comment">// 垂直制表符可能引发终端异常</span></span><br></pre></td></tr></table></figure><hr /><h2 id="三-现代c新增字符类型"><a class="markdownIt-Anchor" href="#三-现代c新增字符类型"></a> 三、现代C++新增字符类型</h2><h3 id="31-应对全球化浪潮"><a class="markdownIt-Anchor" href="#31-应对全球化浪潮"></a> 3.1 应对全球化浪潮</h3><table><thead><tr><th>类型</th><th>字节数</th><th>编码</th><th>字面量前缀</th><th>适用场景</th></tr></thead><tbody><tr><td>char16_t</td><td>2</td><td>UTF-16</td><td>u</td><td>基本多语言平面</td></tr><tr><td>char32_t</td><td>4</td><td>UTF-32</td><td>U</td><td>生僻字/表情符号</td></tr><tr><td>wchar_t</td><td>2/4</td><td>平台相关</td><td>L</td><td>Windows API</td></tr></tbody></table><p><strong>使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char16_t</span> chinese = <span class="string">u&#x27;汉&#x27;</span>;</span><br><span class="line"><span class="type">char32_t</span> emoji = <span class="string">U&#x27;😊&#x27;</span>;</span><br><span class="line">wcout &lt;&lt; <span class="string">L&quot;宽字符字符串&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="32-原始字符串raw-string妙用"><a class="markdownIt-Anchor" href="#32-原始字符串raw-string妙用"></a> 3.2 原始字符串（Raw String）妙用</h3><p><strong>处理正则表达式的救星</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string path = <span class="string">R&quot;(C:\Program Files\V2ray\config.json)&quot;</span>;  <span class="comment">// 无需转义反斜杠</span></span><br><span class="line">string regex = <span class="string">R&quot;(\d&#123;3&#125;-\d&#123;4&#125;)&quot;</span>;  <span class="comment">// 匹配电话号码</span></span><br></pre></td></tr></table></figure><hr /><h2 id="四-必知必会的六大军规"><a class="markdownIt-Anchor" href="#四-必知必会的六大军规"></a> 四、必知必会的六大军规</h2><h3 id="41-浮点数使用守则"><a class="markdownIt-Anchor" href="#41-浮点数使用守则"></a> 4.1 浮点数使用守则</h3><ol><li>金融计算禁用float/double（用decimal库）</li><li>避免连续浮点运算（误差会累积）</li><li>警惕隐式类型转换：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> b = a / <span class="number">2</span>;   <span class="comment">// 结果是2.0！应改为a/2.0</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="42-字符处理雷区"><a class="markdownIt-Anchor" href="#42-字符处理雷区"></a> 4.2 字符处理雷区</h3><ol><li>不要假设char是有符号的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">255</span>;  <span class="comment">// 可能是-1或255，用uint8_t明确</span></span><br></pre></td></tr></table></figure></li><li>慎用C风格字符串：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>] = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 可能溢出，改用string</span></span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="五-调试利器三件必备工具"><a class="markdownIt-Anchor" href="#五-调试利器三件必备工具"></a> 五、调试利器：三件必备工具</h2><h3 id="51-查看内存二进制"><a class="markdownIt-Anchor" href="#51-查看内存二进制"></a> 5.1 查看内存二进制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">3.5f</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;f;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(p[i]) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出IEEE754二进制表示</span></span><br></pre></td></tr></table></figure><h3 id="52-数值极限查询"><a class="markdownIt-Anchor" href="#52-数值极限查询"></a> 5.2 数值极限查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float最小值：&quot;</span> &lt;&lt; numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char是否有符号？&quot;</span> &lt;&lt; numeric_limits&lt;<span class="type">char</span>&gt;::is_signed;</span><br></pre></td></tr></table></figure><h3 id="53-类型转换检测"><a class="markdownIt-Anchor" href="#53-类型转换检测"></a> 5.3 类型转换检测</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> type_check = <span class="number">3.14f</span>;  <span class="comment">// 自动推导为float</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="string">&#x27;A&#x27;</span>) char_type;  <span class="comment">// 推导为char</span></span><br></pre></td></tr></table></figure><hr /><h2 id="结语编程世界的两面性"><a class="markdownIt-Anchor" href="#结语编程世界的两面性"></a> 结语：编程世界的两面性</h2><p>浮点数教会我们接受不完美，字符型展示了表象与本质的辩证关系。当你能优雅处理0.1+0.2的误差，当你看透’A’的整型本质，就真正掌握了计算机世界的语言哲学。下期我们将深入指针迷宫，揭开内存操作的神秘面纱！</p><hr /><p>🚀 <strong>终极挑战</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> magic = <span class="number">0.0</span> / <span class="number">0.0</span>;</span><br><span class="line">cout &lt;&lt; (magic == magic) ? <span class="string">&quot;相等&quot;</span> : <span class="string">&quot;不相等&quot;</span>;  <span class="comment">// 输出什么？</span></span><br></pre></td></tr></table></figure><p>📚 <strong>拓展资源</strong>：</p><ul><li>《深入理解计算机系统》第2章</li><li><a href="https://lukaskollmer.de/ieee-754-visualizer/">IEEE 754在线可视化工具</a></li><li><a href="https://www.lddgo.net/string/unicode-chart">Unicode字符查询表</a></li></ul><p>🛠️ <strong>推荐练习</strong>：</p><ol><li>实现浮点数精确比较模板</li><li>编写ASCII码转换器程序</li><li>测试不同区域设置的字符编码差异</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++入门：简单变量 &amp; 整型</title>
      <link href="/2025/03/08/Cpp%E5%85%A5%E9%97%A8-%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F/"/>
      <url>/2025/03/08/Cpp%E5%85%A5%E9%97%A8-%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="c入门简单变量-整型"><a class="markdownIt-Anchor" href="#c入门简单变量-整型"></a> C++入门：简单变量 &amp; 整型</h1><h2 id="开篇寄语为什么你需要这篇指南"><a class="markdownIt-Anchor" href="#开篇寄语为什么你需要这篇指南"></a> 开篇寄语：为什么你需要这篇指南？</h2><p>最近听到不少同学的抱怨：“C++的数据类型怎么这么难？”“变量和整型总是分不清怎么办？” 看着大家被各种<code>int</code>、<code>short</code>、<code>unsigned</code>绕得团团转，我决定用最接地气的方式，把这块硬骨头啃碎了喂给你们。相信我，学完这篇，你会拍着大腿说：“原来数据类型还能这么理解！”</p><hr /><h2 id="引言从变量盒子到数据存储哲学"><a class="markdownIt-Anchor" href="#引言从变量盒子到数据存储哲学"></a> 引言：从&quot;变量盒子&quot;到数据存储哲学</h2><p><strong>为什么程序员总在讨论数据类型？</strong><br />就像快递员要知道包裹是易碎品还是普通货物，程序需要明确数据是整数还是字符。C++的变量系统，本质上是一套精密的&quot;内存货架管理系统&quot;——给每个数据贴上类型标签，分配合适大小的存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>; <span class="comment">// 给4字节的&quot;货架&quot;贴上&quot;num&quot;标签，存入数字5</span></span><br></pre></td></tr></table></figure><hr /><h2 id="一-变量系统全解析破解初学者三大困惑"><a class="markdownIt-Anchor" href="#一-变量系统全解析破解初学者三大困惑"></a> 一、变量系统全解析（破解初学者三大困惑）</h2><h3 id="11-变量的本质内存空间的命名艺术"><a class="markdownIt-Anchor" href="#11-变量的本质内存空间的命名艺术"></a> 1.1 变量的本质：内存空间的命名艺术</h3><p><strong>新手常见误区</strong>：“声明变量就是创建数据？”<br />实际上：</p><ol><li><code>int num;</code> → 申请4字节内存（32位系统）</li><li><code>num = 5;</code> → 在地址0x7ffe…写入00000101</li><li>从此&quot;num&quot;成为该地址的永久门牌号</li></ol><blockquote><p>💡 <strong>变量三要素记忆口诀</strong>：<br />哪里存（地址）→ 存什么（值）→ 怎么存（类型）</p></blockquote><h3 id="12-变量命名规范代码可读性的第一道防线"><a class="markdownIt-Anchor" href="#12-变量命名规范代码可读性的第一道防线"></a> 1.2 变量命名规范：代码可读性的第一道防线</h3><p><strong>血泪教训案例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;    <span class="comment">// 烂命名：半年后鬼知道a1是什么</span></span><br><span class="line"><span class="type">int</span> nStudentCount = <span class="number">10</span>; <span class="comment">// 好命名：一眼看懂用途</span></span><br></pre></td></tr></table></figure><p><strong>命名进阶技巧</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型前缀法（匈牙利命名法）</span></span><br><span class="line"><span class="type">char</span> szName[<span class="number">20</span>];    <span class="comment">// sz: 以零结尾的字符串</span></span><br><span class="line"><span class="type">float</span> fPrice;       <span class="comment">// f: 浮点型</span></span><br><span class="line"><span class="type">bool</span> bIsValid;      <span class="comment">// b: 布尔型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 骆驼命名法</span></span><br><span class="line"><span class="type">int</span> studentCount; </span><br><span class="line"><span class="type">double</span> totalAmount;</span><br></pre></td></tr></table></figure><hr /><h2 id="二-整型数据类型深度剖析"><a class="markdownIt-Anchor" href="#二-整型数据类型深度剖析"></a> 二、整型数据类型深度剖析</h2><h3 id="21-整型家族图谱五兄弟对比"><a class="markdownIt-Anchor" href="#21-整型家族图谱五兄弟对比"></a> 2.1 整型家族图谱：五兄弟对比</h3><table><thead><tr><th>类型</th><th>内存空间</th><th>数值范围（典型值）</th><th>适用场景</th></tr></thead><tbody><tr><td>char</td><td>1字节</td><td>-128~127 或 0~255</td><td>ASCII字符/微小整数</td></tr><tr><td>short</td><td>2字节</td><td>-32,768~32,767</td><td>节省内存的小数值</td></tr><tr><td>int</td><td>4字节</td><td>-2.1亿~2.1亿</td><td>通用整数存储</td></tr><tr><td>long</td><td>4/8字节</td><td>同int或更大</td><td>历史遗留系统</td></tr><tr><td>long long</td><td>8字节</td><td>-9×10¹⁸~9×10¹⁸</td><td>天文数字计算</td></tr></tbody></table><h3 id="22-有符号与无符号的量子世界"><a class="markdownIt-Anchor" href="#22-有符号与无符号的量子世界"></a> 2.2 有符号与无符号的量子世界</h3><p><strong>二进制视角解密</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> c = <span class="number">-5</span>;    <span class="comment">// 内存存储：11111011</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc = <span class="number">251</span>; <span class="comment">// 同样的二进制，解释为251</span></span><br></pre></td></tr></table></figure><p><strong>实际开发忠告</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险操作：无符号数不会为负</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> balance = <span class="number">100</span>;</span><br><span class="line">balance -= <span class="number">150</span>; <span class="comment">// 结果变成4294967246（巨坑！）</span></span><br></pre></td></tr></table></figure><hr /><h2 id="三-必杀技三大工具实战演示"><a class="markdownIt-Anchor" href="#三-必杀技三大工具实战演示"></a> 三、必杀技：三大工具实战演示</h2><h3 id="31-sizeof你的内存放大镜"><a class="markdownIt-Anchor" href="#31-sizeof你的内存放大镜"></a> 3.1 sizeof：你的内存放大镜</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;long long占内存：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>); <span class="comment">// 输出8</span></span><br><span class="line"><span class="type">short</span> arr[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组总大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr); <span class="comment">// 输出20（2*10）</span></span><br></pre></td></tr></table></figure><h3 id="32-climits数据边界的gps"><a class="markdownIt-Anchor" href="#32-climits数据边界的gps"></a> 3.2 <climits>：数据边界的GPS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int能存的最大值：&quot;</span> &lt;&lt; INT_MAX &lt;&lt; endl; <span class="comment">// 2147483647</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;char的最小值：&quot;</span> &lt;&lt; CHAR_MIN &lt;&lt; endl;   <span class="comment">// -128</span></span><br></pre></td></tr></table></figure><h3 id="33-初始化方式从c到c11的进化"><a class="markdownIt-Anchor" href="#33-初始化方式从c到c11的进化"></a> 3.3 初始化方式：从C到C++11的进化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;          <span class="comment">// 传统C风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;          <span class="comment">// 构造函数风格</span></span><br><span class="line"><span class="type">int</span> c&#123;<span class="number">15</span>&#125;;          <span class="comment">// C++11统一初始化</span></span><br><span class="line"><span class="type">int</span> d = &#123;<span class="number">20</span>&#125;;       <span class="comment">// 带等号版本</span></span><br><span class="line"><span class="type">int</span> e&#123;&#125;;            <span class="comment">// 默认初始化为0</span></span><br></pre></td></tr></table></figure><hr /><h2 id="四-整型溢出程序员的数字轮回陷阱"><a class="markdownIt-Anchor" href="#四-整型溢出程序员的数字轮回陷阱"></a> 四、整型溢出：程序员的数字轮回陷阱</h2><h3 id="41-震撼实验327671-32768"><a class="markdownIt-Anchor" href="#41-震撼实验327671-32768"></a> 4.1 震撼实验：32767+1=-32768？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> maxShort = <span class="number">32767</span>;</span><br><span class="line">maxShort += <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; maxShort; <span class="comment">// 输出-32768（像汽车里程表归零）</span></span><br></pre></td></tr></table></figure><h3 id="42-避免溢出的三大策略"><a class="markdownIt-Anchor" href="#42-避免溢出的三大策略"></a> 4.2 避免溢出的三大策略</h3><ol><li><strong>预估范围法</strong>：存款金额用long long</li><li><strong>静态检测法</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; INT_MAX - b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;警告：即将溢出！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>使用大数库</strong>：处理超过1e18的数值</li></ol><hr /><h2 id="五-常量数据类型判定编译器的小秘密"><a class="markdownIt-Anchor" href="#五-常量数据类型判定编译器的小秘密"></a> 五、常量数据类型判定：编译器的小秘密</h2><h3 id="51-后缀字母的魔法"><a class="markdownIt-Anchor" href="#51-后缀字母的魔法"></a> 5.1 后缀字母的魔法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>     <span class="comment">// int</span></span><br><span class="line"><span class="number">42U</span>    <span class="comment">// unsigned int </span></span><br><span class="line"><span class="number">42L</span>    <span class="comment">// long</span></span><br><span class="line"><span class="number">42ULL</span>  <span class="comment">// unsigned long long</span></span><br><span class="line"><span class="number">3.14F</span>  <span class="comment">// float</span></span><br><span class="line"><span class="number">3.14</span>   <span class="comment">// double</span></span><br></pre></td></tr></table></figure><h3 id="52-隐式转换红黑榜"><a class="markdownIt-Anchor" href="#52-隐式转换红黑榜"></a> 5.2 隐式转换红黑榜</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全转换（升级）</span></span><br><span class="line"><span class="type">short</span> s = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = s;  <span class="comment">// short→int：安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险转换（降级）</span></span><br><span class="line"><span class="type">long</span> l = LONG_MAX;</span><br><span class="line"><span class="type">int</span> i = l;  <span class="comment">// 可能丢失数据！</span></span><br></pre></td></tr></table></figure><hr /><h2 id="六-从新手到高手数据类型选择策略"><a class="markdownIt-Anchor" href="#六-从新手到高手数据类型选择策略"></a> 六、从新手到高手：数据类型选择策略</h2><h3 id="61-日常开发黄金法则"><a class="markdownIt-Anchor" href="#61-日常开发黄金法则"></a> 6.1 日常开发黄金法则</h3><ol><li>默认用<code>int</code>：处理速度最快</li><li>明确范围用<code>unsigned</code>：如物品数量</li><li>超大数值用<code>long long</code>：银行账户余额</li><li>节省内存用<code>short</code>：嵌入式开发</li></ol><h3 id="62-跨平台开发注意事项"><a class="markdownIt-Anchor" href="#62-跨平台开发注意事项"></a> 6.2 跨平台开发注意事项</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保固定位宽</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="type">int32_t</span> fixedInt;   <span class="comment">// 保证32位有符号</span></span><br><span class="line"><span class="type">uint16_t</span> fixedShort; <span class="comment">// 保证16位无符号</span></span><br></pre></td></tr></table></figure><hr /><h2 id="结语编程如烹小鲜火候是关键"><a class="markdownIt-Anchor" href="#结语编程如烹小鲜火候是关键"></a> 结语：编程如烹小鲜，火候是关键</h2><p>记住这些数据类型不是束缚你的牢笼，而是保护程序的铠甲。当你下次写出<code>long long salary = 1e18;</code>时，不妨会心一笑——你已经掌握了让数字乖乖听话的魔法。下期我们将揭开浮点数存储的神秘面纱，让你彻底明白为什么<code>0.1+0.2≠0.3</code>！</p><p><strong>🚀 现在就来挑战</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic = <span class="number">0</span>;</span><br><span class="line">magic -= <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;魔法数字：&quot;</span> &lt;&lt; magic; <span class="comment">// 猜猜会输出什么？</span></span><br></pre></td></tr></table></figure><hr /><p>📝 <strong>拓展资源</strong>：</p><ul><li><a href="https://pythontutor.com/cpp.html">C++数据类型内存可视化工具</a></li><li>《C++ Primer》第2章精读</li></ul><p>📚 <strong>推荐练习</strong>：</p><ol><li>编写程序验证各类型取值范围</li><li>创建不同整型变量并测试运算溢出</li><li>使用sizeof比较各类型内存占用</li></ol><p><strong>扩展阅读</strong>：<a href="https://en.cppreference.com/w/cpp/language/types">C++官方类型文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 教学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P1011 车站 [NOIP 1998 提高组]</title>
      <link href="/2025/03/06/P1011/"/>
      <url>/2025/03/06/P1011/</url>
      
        <content type="html"><![CDATA[<h1 id="p1011-车站-noip-1998-提高组"><a class="markdownIt-Anchor" href="#p1011-车站-noip-1998-提高组"></a> P1011 车站 [NOIP 1998 提高组]</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>火车从始发站（称为第 1 站）开出，在始发站上车的人数为 a，然后到达第 2 站，在第 2 站有人上、下车，但上、下车的人数相同，因此在第 2 站开出时（即在到达第 3 站之前）车上的人数保持为 a 人。从第 3 站起（包括第 3 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 n−1 站），都满足此规律。现给出的条件是：共有 n 个车站，始发站上车的人数为 a，最后一站下车的人数是 m（全部下车）。试问 x 站开出时车上的人数是多少？</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>输入只有一行四个整数，分别表示始发站上车人数 a，车站数 n，终点站下车人数 m 和所求的站点编号 x。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>输出一行一个整数表示答案：从 x 站开出时车上的人数。</p><h2 id="输入输出样例-1"><a class="markdownIt-Anchor" href="#输入输出样例-1"></a> 输入输出样例 #1</h2><h3 id="输入-1"><a class="markdownIt-Anchor" href="#输入-1"></a> 输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 7 32 4</span><br></pre></td></tr></table></figure><h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="说明提示"><a class="markdownIt-Anchor" href="#说明提示"></a> 说明/提示</h2><p>对于全部的测试点，保证 1≤a≤20，1≤x≤n≤20，1≤m≤2×10<sup>4</sup>。</p><h2 id="问题分析-求解"><a class="markdownIt-Anchor" href="#问题分析-求解"></a> 问题分析 + 求解</h2><h3 id="已知信息"><a class="markdownIt-Anchor" href="#已知信息"></a> 已知信息：</h3><ul><li>发站上车人数 a</li><li>车站数 n</li><li>终点站人数 m</li><li>所求的站点编号 x</li></ul><p>我们定义 i：表示第二站上车、下车为 i 人</p><p>根据已知信息，我们可以列出表格：</p><table><thead><tr><th>站数（x）</th><th>上车人数</th><th>下车人数</th><th>发车时的人数</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>/</td><td>a</td></tr><tr><td>2</td><td>i</td><td>i</td><td>a</td></tr><tr><td>3</td><td>a+i</td><td>i</td><td>2a+i</td></tr><tr><td>4</td><td>a+2i</td><td>a+i</td><td>2a+i</td></tr><tr><td>5</td><td>2a+3i</td><td>a+2i</td><td>3a+2i</td></tr></tbody></table><p>我们可以找到规律：</p><p>第 x 站时：</p><p>发车时的人数 = (x-2)*a+(x-3)*i</p><p>经过思考，得出</p><p>最后一站的下车人数=倒数第二站发车时的人数</p><p>我们可以利用最后一站的下车人数来求 i 的值：</p><p>m = (n-3)*a+(n-4)*i</p><p>我们可以写出程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, n, m, x;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求i</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((n - <span class="number">3</span>) * a + (n - <span class="number">4</span>) * i) == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rs = (x - <span class="number">2</span>) * a + (x - <span class="number">3</span>) * i;<span class="comment">//代入公式</span></span><br><span class="line">    cout &lt;&lt; rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，这个程序求 i 的值用的是暴力求解法。</p><p>一个 TLE，一个 WA，其他全过</p><p>所以，这个结果也是意料之中</p><h1 id="orz"><a class="markdownIt-Anchor" href="#orz"></a> orz</h1><p>但是除了暴力方法以外，我实在想不到别的方法了。。。</p><p>但是，我的代码是效率低，出现 TLE 是意料之中，但是这个 WA 又是怎么回事？</p><p>这就不得而知了。。。</p><p>但是这个程序还是<strong>可以优化</strong>的：</p><ol><li><p>优化 i 的求解方法：暴力枚举可以，但 二分查找更快。</p></li><li><p>增加边界保护：防止 x = 1 或 x = 2 时出现计算错误（尽管题目给的范围一般不会触发）。</p></li></ol><p>但是，考虑到 i 的取值范围很小，所以说二分查找可能不比暴力枚举快多少。</p><p>所以我们只针对 x=1，x=2 的情况进行优化。</p><p>但是，加了 if 进行特殊输出后还是有一个 WA，不管了。</p><p>什么时候学了递推再回来改进吧~~</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>参赛作品：算法与数据可视化工具集</title>
      <link href="/2025/03/05/%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
      <url>/2025/03/05/%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="参赛作品算法与数据可视化工具集"><a class="markdownIt-Anchor" href="#参赛作品算法与数据可视化工具集"></a> 参赛作品：算法与数据可视化工具集</h1><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2><h3 id="1-累加计算器与可视化程序"><a class="markdownIt-Anchor" href="#1-累加计算器与可视化程序"></a> <strong>1. 累加计算器与可视化程序</strong></h3><p><strong>功能描述：</strong></p><p>该程序实现了一个简单的累加计算器，用户可以输入一个最小值和一个最大值，程序会计算从最小值到最大值的累加和并可视化累加过程。程序通过条形图展示每步累加的过程，实时显示累加结果。</p><p><strong>主要流程：</strong></p><ol><li>用户输入最小值和最大值。</li><li>程序判断输入是否有效（最小值小于最大值）。</li><li>从最小值到最大值进行累加，并实时更新累加结果。</li><li>通过条形图可视化每一步的累加过程，展示当前最小值和当前累加和。</li><li>计算完成后，通过弹窗显示最终的累加结果。</li></ol><p><strong>使用说明：</strong></p><ol><li>在文本框中输入最小值和最大值。</li><li>点击“计算并可视化”按钮，程序会计算并显示累加结果。</li><li>程序会弹出对话框显示累加结果，并展示累加过程的条形图。</li></ol><p><strong>代码注释：</strong></p><ul><li>entry_min 和 entry_max 是用户输入最小值和最大值的文本框。</li><li>plt.bar() 用于绘制条形图，显示累加过程。</li><li>messagebox.showinfo() 和 messagebox.showerror() 用于弹窗显示信息。</li></ul><h3 id="2-选择排序与可视化程序"><a class="markdownIt-Anchor" href="#2-选择排序与可视化程序"></a> <strong>2. 选择排序与可视化程序</strong></h3><p><strong>功能描述：</strong></p><p>该程序实现了选择排序算法，并通过图形化界面展示每一步的排序过程。用户可以看到选择排序如何通过不断选择最小值并交换位置，逐步将数组排序完成。</p><p><strong>主要流程：</strong></p><ol><li>随机生成一个包含 50 个元素的数组。</li><li>使用选择排序算法对数组进行排序，实时更新数组状态。</li><li>每次交换时，通过条形图展示当前数组状态，突出显示当前最小值、遍历元素以及已排序部分。</li><li>排序完成后，通过可视化展示排序结果。</li></ol><p><strong>使用说明：</strong></p><ol><li>程序会自动生成一个随机数组，并进行选择排序。</li><li>排序过程中会实时绘制条形图，显示每一步的排序情况。</li><li>排序完成后，会显示最终的排序结果。</li></ol><p><strong>代码注释：</strong></p><ul><li>plt.bar() 用于绘制条形图，显示数组的排序过程。</li><li>plt.clf() 用于清除之前的绘图，准备更新图表。</li><li>plt.pause() 用于控制动画的更新速度，使排序过程可视化。</li></ul><h3 id="3-插入排序与可视化程序"><a class="markdownIt-Anchor" href="#3-插入排序与可视化程序"></a> <strong>3. 插入排序与可视化程序</strong></h3><p><strong>功能描述：</strong></p><p>该程序实现了插入排序算法，并通过图形化界面展示每一步的排序过程。用户可以看到插入排序如何通过逐个插入元素到已排序部分，逐步将数组排序完成。</p><p><strong>主要流程：</strong></p><ol><li>随机生成一个包含 50 个元素的数组。</li><li>使用插入排序算法对数组进行排序，实时更新数组状态。</li><li>每次插入元素时，通过条形图展示当前数组状态，突出显示当前插入元素及已排序部分。</li><li>排序完成后，通过可视化展示排序结果。</li></ol><p><strong>使用说明：</strong></p><ol><li>程序会自动生成一个随机数组，并进行插入排序。</li><li>排序过程中会实时绘制条形图，显示每一步的排序情况。</li><li>排序完成后，会显示最终的排序结果。</li></ol><p><strong>代码注释：</strong></p><ul><li>plt.bar() 用于绘制条形图，显示数组的排序过程。</li><li>plt.clf() 用于清除之前的绘图，准备更新图表。</li><li>plt.pause() 用于控制动画的更新速度，使排序过程可视化。</li></ul><h3 id="4-累加计算器带最小值和最大值输入"><a class="markdownIt-Anchor" href="#4-累加计算器带最小值和最大值输入"></a> <strong>4. 累加计算器（带最小值和最大值输入）</strong></h3><p><strong>功能描述：</strong></p><p>该程序是一个简单的累加计算器，用户输入最小值和最大值，程序会计算这两个值之间所有整数的累加和，并通过条形图展示累加过程。</p><p><strong>主要流程：</strong></p><ol><li>用户输入最小值和最大值。</li><li>程序判断输入是否有效，确保最小值小于最大值。</li><li>从最小值到最大值进行累加，并实时更新累加和。</li><li>通过条形图可视化每步累加过程，显示当前最小值和当前累加和。</li></ol><p><strong>使用说明：</strong></p><ol><li>在文本框中输入最小值和最大值。</li><li>点击“计算并可视化”按钮，程序会计算并显示累加结果。</li><li>程序会弹出对话框显示累加结果，并展示累加过程的条形图。</li></ol><p><strong>代码注释：</strong></p><ul><li>plt.bar() 用于绘制条形图，显示每一步的累加过程。</li><li>messagebox.showinfo() 用于显示累加结果。</li><li>messagebox.showerror() 用于处理输入错误。</li></ul><p><strong>总结</strong></p><p>这四个程序分别实现了不同类型的排序与累加计算功能，并通过图形化界面进行可视化展示。程序的设计思路简单，主要用于帮助学习者理解排序算法和累加过程，同时通过图表展示，使得排序和计算过程更加直观易懂。</p><p>每个程序都有清晰的用户输入和交互逻辑，确保用户能够顺利使用程序，并通过可视化的方式获得排序或累加过程的实时反馈。这种设计非常适合用于教学和演示。</p><h2 id="下载-配置"><a class="markdownIt-Anchor" href="#下载-配置"></a> 下载、配置</h2><h3 id="下载链接"><a class="markdownIt-Anchor" href="#下载链接"></a> 下载链接</h3><h4 id=""><a class="markdownIt-Anchor" href="#"></a> /</h4><p>主程序：</p><p><a href="http://49.233.16.143/wp-content/uploads/2025/03/%E4%B8%BB%E7%A8%8B%E5%BA%8F.zip">主程序</a> <a href="http://49.233.16.143/wp-content/uploads/2025/03/%E4%B8%BB%E7%A8%8B%E5%BA%8F.zip">下载</a></p><h4 id="subprogram"><a class="markdownIt-Anchor" href="#subprogram"></a> /subprogram</h4><p>子程序#1.zip：</p><p><a href="https://wwig.lanzoue.com/iOzG42pp53vc">https://wwig.lanzoue.com/iOzG42pp53vc</a></p><p>子程序#2.zip：</p><p><a href="https://wwig.lanzoue.com/iKIeD2pp54qd">https://wwig.lanzoue.com/iKIeD2pp54qd</a></p><h3 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根目录</span><br><span class="line">├── main.exe</span><br><span class="line">└── subprogram</span><br><span class="line">        ├── InsertionSorting.exe</span><br><span class="line">        ├── DanWeiHuanSuanQi.exe</span><br><span class="line">        ├── LeiJiaJiSuanQi.exe</span><br><span class="line">        └── SelectionSort.exe</span><br></pre></td></tr></table></figure><hr />]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P1421 小玉买文具</title>
      <link href="/2025/03/04/P1421/"/>
      <url>/2025/03/04/P1421/</url>
      
        <content type="html"><![CDATA[<h1 id="p1421-小玉买文具"><a class="markdownIt-Anchor" href="#p1421-小玉买文具"></a> P1421 小玉买文具</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 1 元 9 角，而班主任给小玉的钱是 a 元 b 角，小玉想知道，她最多能买多少只签字笔呢。</p><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p>输入只有一行两个整数，分别表示 a 和 b。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>输出一行一个整数，表示小玉最多能买多少只签字笔。</p><h3 id="输入输出样例"><a class="markdownIt-Anchor" href="#输入输出样例"></a> 输入输出样例</h3><h4 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br></pre></td></tr></table></figure><h4 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="说明提示"><a class="markdownIt-Anchor" href="#说明提示"></a> 说明/提示</h3><h4 id="数据规模与约定"><a class="markdownIt-Anchor" href="#数据规模与约定"></a> 数据规模与约定</h4><p>对于全部的测试点，保证 0 ≤ a ≤ 10^4，0 ≤ b ≤ 9。</p><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2><p>无须分析。</p><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double DanJia = 1.9;</span><br><span class="line">    int a = 0, b = 0;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    double GiveMoney = a + 0.1 * b;</span><br><span class="line">    int GeShu = GiveMoney / DanJia;</span><br><span class="line">    cout &lt;&lt; GeShu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC，完美通过！</p><p>本篇题解到此结束，</p><h1 id="祝各位读者早日成为神牛牪犇"><a class="markdownIt-Anchor" href="#祝各位读者早日成为神牛牪犇"></a> 祝各位读者早日成为神牛牪犇！</h1>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P5711 【深基3.例3】闰年判断</title>
      <link href="/2025/03/04/P5711/"/>
      <url>/2025/03/04/P5711/</url>
      
        <content type="html"><![CDATA[<h1 id="p5711-深基3例3闰年判断"><a class="markdownIt-Anchor" href="#p5711-深基3例3闰年判断"></a> P5711 【深基3.例3】闰年判断</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>输入一个年份，判断这一年是否是闰年，如果是输出 <code>1</code>，否则输出 <code>0</code>。</p><p>1582 年以来，闰年的定义：</p><ul><li><strong>普通闰年</strong>：公历年份是 <code>4</code> 的倍数，且不是 <code>100</code> 的倍数的，为闰年（如 <code>2004</code> 年、<code>2020</code> 年等就是闰年）。</li><li><strong>世纪闰年</strong>：公历年份是整百数的，必须是 <code>400</code> 的倍数才是闰年（如 <code>1900</code> 年不是闰年，<code>2000</code> 年是闰年）。</li></ul><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p>输入一个正整数 <code>n</code>，表示年份。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>输出一行。如果输入的年份是闰年则输出 <code>1</code>，否则输出 <code>0</code>。</p><h2 id="输入输出样例"><a class="markdownIt-Anchor" href="#输入输出样例"></a> 输入输出样例</h2><h3 id="输入输出样例-1"><a class="markdownIt-Anchor" href="#输入输出样例-1"></a> 输入输出样例 #1</h3><p><strong>输入 #1</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1926</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输入输出样例-2"><a class="markdownIt-Anchor" href="#输入输出样例-2"></a> 输入输出样例 #2</h3><p><strong>输入 #2</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1900</span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输入输出样例-3"><a class="markdownIt-Anchor" href="#输入输出样例-3"></a> 输入输出样例 #3</h3><p><strong>输入 #3</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><p><strong>输出 #3</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="输入输出样例-4"><a class="markdownIt-Anchor" href="#输入输出样例-4"></a> 输入输出样例 #4</h3><p><strong>输入 #4</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1996</span><br></pre></td></tr></table></figure><p><strong>输出 #4</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="说明提示"><a class="markdownIt-Anchor" href="#说明提示"></a> 说明/提示</h2><p>数据保证，<code>1582 ≤ n ≤ 2020</code> 且年份为自然数。</p><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>)) || (year % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美通过！</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>T392143 水仙花数</title>
      <link href="/2025/03/04/T392143%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"/>
      <url>/2025/03/04/T392143%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="t392143-水仙花数"><a class="markdownIt-Anchor" href="#t392143-水仙花数"></a> T392143 水仙花数</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>在自然数中，如果一个三位数等于自身各位数字之立方和，则这个三位数就称为是水仙花数。如:153=1+125+27,所以153是一个水仙花数。求所有的水仙花数。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>无输入</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>若干个空格间隔的由小到大表示的整数，每个表示一个水仙花数。</p><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题</h2><p>是不是很熟悉？这道题就是《算法竞赛入门经典》的习题 2-1，改一个输出就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">100</span>; num &lt;= <span class="number">999</span>; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = num / <span class="number">100</span>;</span><br><span class="line">        b = (num / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        c = num % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num == (a * a * a) + (b * b * b) + (c * c * c))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美通过！</p><p>本篇题解到此结束，祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法竞赛入门经典 第二章习题解答</title>
      <link href="/2025/03/03/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
      <url>/2025/03/03/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="算法竞赛入门经典-第二章习题解答"><a class="markdownIt-Anchor" href="#算法竞赛入门经典-第二章习题解答"></a> 算法竞赛入门经典 第二章习题解答</h1><hr /><h2 id="习题-2-1-水仙花数daffodil"><a class="markdownIt-Anchor" href="#习题-2-1-水仙花数daffodil"></a> 习题 2-1 水仙花数（daffodil）</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>输出 100～999 中的所有水仙花数。若 3 位数 ABC 满足</p><p>[<br />ABC = A^3 + B^3 + C^3<br />]</p><p>则称其为水仙花数。例如 153= (1<sup>3+5</sup>3+3^3) ，所以 153 是水仙花数。</p><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">100</span>; num &lt;= <span class="number">999</span>; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = num / <span class="number">100</span>;</span><br><span class="line">        b = (num / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        c = num % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num == (a * a * a) + (b * b * b) + (c * c * c))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么可说的。</p><hr /><h2 id="习题-2-2-韩信点兵hanxin"><a class="markdownIt-Anchor" href="#习题-2-2-韩信点兵hanxin"></a> 习题 2-2 韩信点兵（hanxin）</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形，而他每次只掠一眼队伍的排尾就知道总人数了。<br />输入包含多组数据，每组数据包含 3 个非负整数 <code>a, b, c</code>，表示每种队形排尾的人数（<code>a &lt; 3, b &lt; 5, c &lt; 7</code>），输出总人数的最小值（或报告无解）。已知总人数不小于 10，不超过 100。输入到文件结束为止。</p><h4 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> <strong>样例输入</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1 6</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> <strong>样例输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 41</span><br><span class="line">Case 2: No answer</span><br></pre></td></tr></table></figure><h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3><p><strong>初版（有 bug）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">10</span>; num &lt;= <span class="number">100</span>; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num % <span class="number">3</span> == a) &amp;&amp; (num % <span class="number">5</span> == b) &amp;&amp; (num % <span class="number">7</span> == c))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No answer&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answerNo answer41</span><br></pre></td></tr></table></figure><p>这样肯定不对。<br />动了一下聪明的大脑，想出以下解决方法：</p><h3 id="修正版本"><a class="markdownIt-Anchor" href="#修正版本"></a> <strong>修正版本</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">10</span>; num &lt;= <span class="number">100</span>; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num % <span class="number">3</span> == a) &amp;&amp; (num % <span class="number">5</span> == b) &amp;&amp; (num % <span class="number">7</span> == c))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!found)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No answer&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就对了。<br />在此基础上，还需要添加多组数据处理，这里以后会出文章讲解，所以这里不再说明。</p><hr /><h2 id="习题-2-3-倒三角形triangle"><a class="markdownIt-Anchor" href="#习题-2-3-倒三角形triangle"></a> 习题 2-3 倒三角形（triangle）</h2><p>移步 <a href="#">算法入门经典 习题 2-3</a></p><hr /><h2 id="习题-2-4-子序列的和subsequence"><a class="markdownIt-Anchor" href="#习题-2-4-子序列的和subsequence"></a> 习题 2-4 子序列的和（subsequence）</h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>输入两个正整数 <code>n &lt; m &lt; 10^6</code>，输出</p><p>[<br />\frac{1}{n^2} + \frac{1}{(n+1)^2} + … + \frac{1}{m^2}<br />]</p><p>保留 5 位小数。输入包含多组数据，结束标记为 <code>n = m = 0</code>。</p><h4 id="样例输入-2"><a class="markdownIt-Anchor" href="#样例输入-2"></a> <strong>样例输入</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">65536 655360</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h4 id="样例输出-2"><a class="markdownIt-Anchor" href="#样例输出-2"></a> <strong>样例输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 0.42361</span><br><span class="line">Case 2: 0.00001</span><br></pre></td></tr></table></figure><h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n &lt;= m; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="number">1.0</span> / (<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(n) * n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目中的陷阱可能指：</p><ol><li>大数溢出；</li><li>分数的值使用浮点数。</li></ol><p>所以，我们可以这样解决：</p><ol><li>将 n 和 m 声明为 long long 类型，确保大数计算不溢出。</li><li>在计算 n*n 时，通过 static_cast(n) 转换为浮点数运算，避免整数溢出。</li><li>使用 double 类型累加和，保留足够精度。</li><li>fixed &lt;&lt; setprecision(5) 控制输出保留五位小数。</li></ol><p>和之前一样，在此基础上，还需要添加多组数据处理，这里以后会出文章讲解，所以这里不再说明。</p><hr /><h2 id="习题-2-5-分数化小数decimal"><a class="markdownIt-Anchor" href="#习题-2-5-分数化小数decimal"></a> 习题 2-5 分数化小数（decimal）</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>输入正整数 <code>a, b, c</code>，输出 <code>a/b</code> 的小数形式，精确到小数点后 <code>c</code> 位。<br /><code>a, b ≤ 10^6</code>，<code>c ≤ 100</code>。输入包含多组数据，结束标记为 <code>a = b = c = 0</code>。</p><h4 id="样例输入-3"><a class="markdownIt-Anchor" href="#样例输入-3"></a> <strong>样例输入</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 6 4</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><h4 id="样例输出-3"><a class="markdownIt-Anchor" href="#样例输出-3"></a> <strong>样例输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 0.1667</span><br></pre></td></tr></table></figure><h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="type">double</span> ans = a / b;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(c) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前一样，在此基础上，还需要添加多组数据处理，这里以后会出文章讲解，所以这里不再说明。</p><hr /><h2 id="习题-2-6-排列permutation"><a class="markdownIt-Anchor" href="#习题-2-6-排列permutation"></a> 习题 2-6 排列（permutation）</h2><h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3><p>用 <code>1,2,3,…,9</code> 组成 3 个三位数 <code>abc, def, ghi</code>，每个数字恰好使用一次，要求 <code>abc:def:ghi=1:2:3</code>。<br />按照 <strong>“abc def ghi”</strong> 的格式输出所有解，每行一个解。</p><h3 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f, g, h, i;</span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(b = <span class="number">1</span>; b &lt;= <span class="number">9</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(c = <span class="number">1</span>; c &lt;= <span class="number">9</span>; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(d = <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(e = <span class="number">1</span>; e &lt;= <span class="number">9</span>; e++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(f = <span class="number">1</span>; f &lt;= <span class="number">9</span>; f++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(g = <span class="number">1</span>; g &lt;= <span class="number">9</span>; g++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">for</span>(h = <span class="number">1</span>; h &lt;= <span class="number">9</span>; h++)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(<span class="number">2</span> * (a * <span class="number">100</span> + b * <span class="number">10</span> + c) == (d * <span class="number">100</span> + e * <span class="number">10</span> + f) &amp;&amp;</span><br><span class="line">                                           <span class="number">3</span> * (a * <span class="number">100</span> + b * <span class="number">10</span> + c) == (g * <span class="number">100</span> + h * <span class="number">10</span> + i) &amp;&amp;</span><br><span class="line">                                           a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; a != e &amp;&amp; a != f &amp;&amp;</span><br><span class="line">                                           a != g &amp;&amp; a != h &amp;&amp; a != i &amp;&amp; b != c &amp;&amp; b != d &amp;&amp;</span><br><span class="line">                                           b != e &amp;&amp; b != f &amp;&amp; b != g &amp;&amp; b != h &amp;&amp; b != i &amp;&amp;</span><br><span class="line">                                           c != d &amp;&amp; c != e &amp;&amp; c != f &amp;&amp; c != g &amp;&amp; c != h &amp;&amp;</span><br><span class="line">                                           c != i &amp;&amp; d != e &amp;&amp; d != f &amp;&amp; d != g &amp;&amp; d != h &amp;&amp;</span><br><span class="line">                                           d != i &amp;&amp; e != f &amp;&amp; e != g &amp;&amp; e != h &amp;&amp; e != i &amp;&amp;</span><br><span class="line">                                           f != g &amp;&amp; f != h &amp;&amp; f != i &amp;&amp; g != h &amp;&amp; g != i &amp;&amp;</span><br><span class="line">                                           h != i)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            cout &lt;&lt; a * <span class="number">100</span> + b * <span class="number">10</span> + c &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                                                 &lt;&lt; d * <span class="number">100</span> + e * <span class="number">10</span> + f &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                                                 &lt;&lt; g * <span class="number">100</span> + h * <span class="number">10</span> + i &lt;&lt; endl;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>emm…<br />没什么好说的，暴力求解法……</p><hr /><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h2><p>至此，我们已经完成了 <strong>《算法竞赛入门经典》第二章</strong> 的学习。<br />愿你在不断调试代码与思维的过程中，感受到算法之美与编程之乐！<br /><strong>下一章，我们不见不散！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 习题 2-3</title>
      <link href="/2025/02/27/%E4%B9%A0%E9%A2%982-3/"/>
      <url>/2025/02/27/%E4%B9%A0%E9%A2%982-3/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-习题-2-3"><a class="markdownIt-Anchor" href="#算法入门经典-习题-2-3"></a> 算法入门经典 习题 2-3</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>输入正整数 n≤20，输出一个 n 层的倒三角形。</p><p>例如，n＝5 时输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#########</span><br><span class="line"> #######</span><br><span class="line">  #####</span><br><span class="line">   ###</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>我们来分析一下：</p><table><thead><tr><th>行号</th><th>空格数</th><th>符号数</th><th>输出内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>9</td><td>#########</td></tr><tr><td>1</td><td>1</td><td>7</td><td>#######</td></tr><tr><td>2</td><td>2</td><td>5</td><td>#####</td></tr><tr><td>3</td><td>3</td><td>3</td><td>###</td></tr><tr><td>4</td><td>4</td><td>1</td><td>#</td></tr></tbody></table><h3 id="初版有-bug"><a class="markdownIt-Anchor" href="#初版有-bug"></a> 初版（有 bug）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">triangle</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a:层数</span></span><br><span class="line">    a = a * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i:每行个数</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加空格</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//b:每行输出次数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">triangle</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">  ###</span><br><span class="line">    #####</span><br><span class="line">      #######</span><br><span class="line">        #########</span><br></pre></td></tr></table></figure><p>可以看出，这个程序的空格输出无误，</p><p>写完了才发现，题目里要求的是倒三角型，而这个程序实现的是正三角形，无奈，推翻重做。</p><p>并且，经过后续 debug 发现，第 k 行需要输出 2*(n – k) – 1 个 #，才是倒三角型。</p><h3 id="修改后不够简洁"><a class="markdownIt-Anchor" href="#修改后不够简洁"></a> 修改后（不够简洁）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">triangle</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a:层数</span></span><br><span class="line">    a = a * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i:每行个数</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加空格</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &lt;= <span class="number">2</span>*(a - i) - <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//b:每行输出次数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">triangle</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##################</span><br><span class="line">  ##############</span><br><span class="line">    ##########</span><br><span class="line">      ######</span><br><span class="line">        ##</span><br></pre></td></tr></table></figure><p>还是和原题目不符。</p><p>我觉得，问题应该出在这一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a:层数</span></span><br><span class="line">a = a * <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这一行是忘记删掉的，删掉后可以正常输出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">triangle</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a:总行数</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//当前操作的行号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a; i = i + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i:每行个数</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加空格</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &lt;= <span class="number">2</span>*(a - i) - <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//b:每行输出次数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">triangle</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#########</span><br><span class="line"> #######</span><br><span class="line">  #####</span><br><span class="line">   ###</span><br><span class="line">    #</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>细心的读者可能会发现，输出多了空行！</p><p>在算法竞赛时，因为这一行空行就可能被判为错误答案！</p><h3 id="修正while-循环最终版"><a class="markdownIt-Anchor" href="#修正while-循环最终版"></a> 修正（while 循环最终版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">triangle</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++)  <span class="comment">//改正：i &lt;= a ==》 i &lt; a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b++ &lt; <span class="number">2</span> * (a - i) - <span class="number">1</span>)  <span class="comment">//改正：2 * (a - i) - 2 ==》 2 * (a - i) - 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">triangle</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此，输入输出没有问题。</p><h3 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h3><p>第 k 行的 # 数量为：</p><p>2*(n – k) – 1</p><p>可以明显感受到，难度陡然上升，希望对程序的理解更上一层楼吧！</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 2-4</title>
      <link href="/2025/02/26/%E4%BE%8B%E9%A2%982-4/"/>
      <url>/2025/02/26/%E4%BE%8B%E9%A2%982-4/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-2-4"><a class="markdownIt-Anchor" href="#算法入门经典-例题-2-4"></a> 算法入门经典 例题 2-4</h1><p>访问量：31</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>阶乘之和：输入 n，计算 S＝1！＋2！＋3！＋…＋n！的末 6 位（不含前导 0）。n≤10<sup>6</sup> ，n！表示前 n 个正整数之积。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37913</span><br></pre></td></tr></table></figure><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>这里应该用双层 for 循环，对于每个 i，乘每一个 j（如程序）。</p><h3 id="初版有-bug"><a class="markdownIt-Anchor" href="#初版有-bug"></a> 初版（有 bug）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = i * j;</span><br><span class="line">            sum = sum + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum % <span class="number">1000000</span>;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欸？输出是 0？</p><p>经过 debug 发现，未初始化循环变量，我在使用循环变量 i 和 j 时没有初始化。</p><h3 id="改正版有-bug"><a class="markdownIt-Anchor" href="#改正版有-bug"></a> 改正版（有 bug）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = i * j;</span><br><span class="line">            sum = sum + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum % <span class="number">1000000</span>;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人费解的是，程序仍然有 bug。</p><p>发现：</p><p>你在内层循环中使用了 <code>a = i * j;</code>，这会导致计算出错误的阶乘。正确的做法应该是 <code>a *= j;</code>，因为阶乘是通过逐步相乘得到的。</p><p>——ChatGPT</p><p>为什么？？？</p><h3 id="核心算法a-j"><a class="markdownIt-Anchor" href="#核心算法a-j"></a> 核心算法（a *= j）</h3><p>使用 <code>a *= j</code> 来计算阶乘的原因是因为阶乘的计算是通过逐步乘积的方式进行的。具体来说，n! 是指从 1 到 n 的所有整数相乘。</p><p>我们可以这样表达 n!：</p><p>n! = 1 × 2 × 3 × ⋯ × n</p><p>因此，为了逐步计算阶乘，我们需要从 1 开始，将每个数字依次乘上当前的 j。</p><p>举个栗子：</p><p>假设我们要计算 5!，即 5! = 1 * 2 * 3 * 4 * 5。</p><p>初始时 a = 1（因为阶乘的起始值是 1）。</p><ul><li>第一次循环：a = 1 * 1 = 1（这就是 1!）。</li><li>第二次循环：a = 1 * 2 = 2（这就是 2!）。</li><li>第三次循环：a = 2 * 3 = 6（这就是 3!）。</li><li>第四次循环：a = 6 * 4 = 24（这就是 4!）。</li><li>第五次循环：a = 24 * 5 = 120（这就是 5!）。</li></ul><p>最终 a 的值为 120，这就是 5! 的正确值。</p><p>所以，正确做法是 <code>a *= j</code>。</p><p>但是，我未免有一个疑问：</p><p>这样的话，外层循环有什么用？？</p><h3 id="为什么需要外层循环"><a class="markdownIt-Anchor" href="#为什么需要外层循环"></a> 为什么需要外层循环？</h3><p>在计算阶乘和时，我们需要依次计算每个数字的阶乘，从 1! 到 n!。这个过程是通过逐个增加数字来完成的。外层循环的作用就是遍历从 1 到 n 的每个整数，确保我们能计算出每个阶乘并累加到总和中。</p><p>也就是说，外层循环的变量 i 表示当前正在计算的是 i!，也就是阶乘的目标数字。</p><p>再简单一点，就是外层循环（i） 用来控制要计算哪个阶乘（i!），从 1! 到 n!。</p><p>再举两个栗子：</p><ol><li><p>假设 n = 5，我们要计算 1! + 2! + 3! + 4! + 5!：</p><ul><li>当 i = 1 时：计算 1!，内层循环执行一次，a = 1。<ul><li>将 1! 加入到总和。</li></ul></li><li>当 i = 2 时：计算 2! = 1 * 2，内层循环执行两次。<ul><li>将 2! 加入到总和。</li></ul></li><li>当 i = 3 时：计算 3! = 1 * 2 * 3，内层循环执行三次。<ul><li>将 3! 加入到总和。</li></ul></li><li>当 i = 4 时：计算 4! = 1 * 2 * 3 * 4，内层循环执行四次。<ul><li>将 4! 加入到总和。</li></ul></li><li>当 i = 5 时：计算 5! = 1 * 2 * 3 * 4 * 5，内层循环执行五次。<ul><li>将 5! 加入到总和。</li></ul></li></ul></li><li><p>假设 n = 3：</p><ul><li>第一次迭代：i = 1，内层循环计算 1!。a = 1<ul><li>累加到 sum 中。</li></ul></li><li>第二次迭代：i = 2，内层循环计算 2!。a = 1 * 2 = 2<ul><li>累加到 sum 中。</li></ul></li><li>第三次迭代：i = 3，内层循环计算 3!。a = 1 * 2 * 3 = 6<ul><li>累加到 sum 中。</li></ul></li></ul><ul><li>最终，sum 就是 1! + 2! + 3! = 1 + 2 + 6 = 9。</li></ul></li></ol><p>因此，第一层循环<strong>是必需的</strong>，它控制了计算哪个阶乘以及循环的次数。没有它，我们无法正确地遍历每个数字并计算每个阶乘。</p><p>至此，我对这个程序没有任何疑问了。</p><h3 id="继续解答"><a class="markdownIt-Anchor" href="#继续解答"></a> 继续解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a * j;</span><br><span class="line">            sum = sum + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum % <span class="number">1000000</span>;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，输出仍然不对。</p><p>发现：在内层循环中，每次都重新计算 <code>a = a * j;</code>，并且 sum 在每次内层循环时都被累加。其实只需要在内层循环结束后，将最终的阶乘值累加到 sum 中，而不是每次乘法后都加到 sum。</p><p>也就是说，将语句 <code>sum = sum + a;</code> 放在外层循环。</p><h3 id="最终版本"><a class="markdownIt-Anchor" href="#最终版本"></a> 最终版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a * j;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum + a;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum % <span class="number">1000000</span>;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这里使用的是数据类型 long long，若您的电脑不支持，请修改）</p><p>其实这个程序也能使用单层循环实现，但是我不会 ʅ（´◔౪◔）ʃ 如有大佬还请赐教了。</p><p>这个程序是自从打开这本书以来，遇到过最难的程序了。希望下一次能秒懂这些题吧。</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>杂谈 NOI 路线</title>
      <link href="/2025/02/26/%E6%9D%82%E8%B0%88NOI%E8%B7%AF%E7%BA%BF/"/>
      <url>/2025/02/26/%E6%9D%82%E8%B0%88NOI%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈-noi-路线"><a class="markdownIt-Anchor" href="#杂谈-noi-路线"></a> 杂谈 NOI 路线</h1><p>刷知乎无意间刷到问题<a href="%5Bhttps://www.zhihu.com/question/292823177/answer/482747918">如何看待《算法竞赛进阶指南》与《信息学奥赛一本通·提高篇》多页内容雷同，后者疑似抄袭？</a>中，李煜东大佬推荐的学习流程竟然惊人的一致为了能帮助广大和我一样的苦命 OIer，特地转载一下：</p><blockquote><p>OI / ICPC 入门到提高的话…… 我的建议是</p><ol><li>买一本《C++ Primer Plus》（中文版就行），看前几章学语言（不用看面向对象之后的内容）。</li><li>买一本《算法竞赛入门经典》，学入门级别算法，上面也有一些语言的内容，所以 C++ Primer Plus 粗略地读就行了。</li><li>买一本《算法竞赛进阶指南》，提高算法和数据结构水平。</li><li>UPD：还有评论推荐《挑战程序设计竞赛》，不过我没读过…… 看作者应该还不错</li></ol><p>之后就不用看书了，刷 OJ / 读论文 / 做 CF 等 Online Contest 应该都不是难事。</p></blockquote><p>附一个回复：</p><blockquote><p>Ircon：请问对于您提到的那些书里面的例题，应该抱着什么态度去刷。是尽量自己做出。还是模仿例题代码写一遍后，搞明白原理，然后去刷习题？</p><p>李煜东：可以自己先简单思考一下，然后搞明白怎么做，最后独立写代码实现。不会的话可以学习例题的解法，代码尽量不要模仿，除非看完解法还是不懂……</p></blockquote><h3 id="版权声明"><a class="markdownIt-Anchor" href="#版权声明"></a> 版权声明：</h3><p>本文转载自知乎，“如何看待《算法竞赛进阶指南》与《信息学奥赛一本通·提高篇》多页内容雷同，后者疑似抄袭？”，<a href="https://www.zhihu.com/question/292823177/answer/482747918">https://www.zhihu.com/question/292823177/answer/482747918</a>。版权归原作者所有，转载目的仅为分享知识与经验。如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈集萃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 2-2</title>
      <link href="/2025/02/25/%E4%BE%8B%E9%A2%982-2/"/>
      <url>/2025/02/25/%E4%BE%8B%E9%A2%982-2/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-2-2"><a class="markdownIt-Anchor" href="#算法入门经典-例题-2-2"></a> 算法入门经典 例题 2-2</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>猜想：对于任意大于1的自然数n，若n为奇数，则将n变为3n＋1，否则变为n的一半。<br />经过若干次这样的变换，一定会使n变为1。例如，3→10→5→16→8→4→2→1。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>很简单的重复性程序，没什么技术含量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            n = <span class="number">3</span> * n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，为了防止数据溢出，我们可以把变量改为 <code>long</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            n = <span class="number">3</span> * n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 2-1</title>
      <link href="/2025/02/24/%E4%BE%8B%E9%A2%982-1/"/>
      <url>/2025/02/24/%E4%BE%8B%E9%A2%982-1/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-2-1"><a class="markdownIt-Anchor" href="#算法入门经典-例题-2-1"></a> 算法入门经典 例题 2-1</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>输出所有形如 aabb 的 4 位完全平方数（即前两位数字相等，后两位数字也相等）。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>这个题目乍一看，有两种思路：</p><ol><li>列举所有完全平方数，再找其中形如 aabb 的。</li><li>列举所有形如 aabb 的数，再找其中的完全平方数。</li></ol><p>经过我的抉择，我选择了第一种思路</p><p>（绝对不是因为我不会判断一个数是否为完全平方数）</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> allnum = i * i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allnum &gt; <span class="number">9999</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a1 = allnum / <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a2 = allnum / <span class="number">100</span> - a1 * <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b1 = allnum / <span class="number">10</span> - a1 * <span class="number">100</span> - a2 * <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b2 = allnum / <span class="number">1</span> - a1 * <span class="number">1000</span> - a2 * <span class="number">100</span> - b1 * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a1 == a2 &amp;&amp; b1 == b2)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; allnum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序没有问题，但是判断是否为 aabb 的数的过程未免太不优雅了！</p><p>所以，我给出了版本 2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> allnum = i * i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allnum &gt; <span class="number">9999</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a1 = allnum / <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a2 = (allnum / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b1 = (allnum / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b2 = allnum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a1 == a2 &amp;&amp; b1 == b2)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; allnum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样感觉也挺好。</p><p>但是这里有一种更加简洁的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">32</span>; i &lt;= <span class="number">99</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = i * i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a1 = num / <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a2 = (num / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b1 = (num / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b2 = num % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a1 == a2 &amp;&amp; b1 == b2)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里运用了四位数的平方根范围为 32~99 的知识。</p><p>但是，我想说：考场上我怎么知道四位数的平方根范围为 32~99？？？</p><p>花絮：一开始看到输出只有 7744 时，我还以为程序写错了，满大街找起来 bug 了 ಠ_ಠ 。</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法竞赛入门经典 第一章习题解答</title>
      <link href="/2025/02/22/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
      <url>/2025/02/22/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="算法竞赛入门经典-第一章习题解答"><a class="markdownIt-Anchor" href="#算法竞赛入门经典-第一章习题解答"></a> 算法竞赛入门经典 第一章习题解答</h1><h2 id="习题-1-1-平均数average"><a class="markdownIt-Anchor" href="#习题-1-1-平均数average"></a> 习题 1-1 平均数（average）</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>输入3个整数，输出它们的平均值，保留3位小数。</p><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">average</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> sum,aver;</span><br><span class="line">    sum = a + b + c;</span><br><span class="line"></span><br><span class="line">    aver = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> aver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,c,ans;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">average</span>(a,b,c);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太过于基础，不过多描述。</p><h2 id="习题1-2-温度temperature"><a class="markdownIt-Anchor" href="#习题1-2-温度temperature"></a> 习题1-2 温度（temperature）</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>输入华氏温度f，输出对应的摄氏温度c，保留3位小数。提示：c＝5（f－32）/9。</p><h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f,c;</span><br><span class="line">    cin &gt;&gt; f;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">5.0</span> * (f - <span class="number">32</span>) / <span class="number">9</span>;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是相当简单的。</p><h2 id="习题1-3-连续和sum"><a class="markdownIt-Anchor" href="#习题1-3-连续和sum"></a> 习题1-3 连续和（sum）</h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>输入正整数n，输出1＋2＋…＋n的值。提示：目标是解决问题，而不是练习编程。</p><h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3><p>终于是上难度了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> EndNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= EndNumber;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> EndNumber,ans;</span><br><span class="line">    cin &gt;&gt; EndNumber;</span><br><span class="line">    ans = <span class="built_in">sum</span>(EndNumber);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题也可以用 <strong>等差数列求和公式</strong> 来解决。</p><p>等差数列求和公式：Sum=[n×(n+1)]/2</p><h2 id="习题1-4-正弦和余弦sin-and-cos"><a class="markdownIt-Anchor" href="#习题1-4-正弦和余弦sin-and-cos"></a> 习题1-4 正弦和余弦（sin and cos）</h2><p>┐(‘～`；)┌ 我才初二啊，数学没学，不会</p><h2 id="习题1-5-打折discount"><a class="markdownIt-Anchor" href="#习题1-5-打折discount"></a> 习题1-5 打折（discount）</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>一件衣服95元，若消费满300元，可打八五折。输入购买衣服件数，输出需要支付的金额（单位：元），保留两位小数。</p><h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> qty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> money = <span class="number">95.0</span> * qty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (money &gt;= <span class="number">300.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        money = money * <span class="number">0.85</span>;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> qty;</span><br><span class="line">    <span class="type">float</span> money;</span><br><span class="line">    cin &gt;&gt; qty;</span><br><span class="line">    money = <span class="built_in">pay</span>(qty);</span><br><span class="line">    cout &lt;&lt; money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题1-6-三角形triangle"><a class="markdownIt-Anchor" href="#习题1-6-三角形triangle"></a> 习题1-6 三角形（triangle）</h2><h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3><p>输入三角形3条边的长度值（均为正整数），判断是否能为直角三角形的3个边长。如果可以，则输出yes，如果不能，则输出no。如果根本无法构成三角形，则输出not a triangle。</p><h3 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a + b &lt;= c) || (a + c &lt;= b) || (b + c &lt;= a))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not a triangle&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a * a))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两边之和大于第三边判断是否为三角形，使用勾股定理判断是否为直角三角形。</p><h2 id="习题1-7-年份year"><a class="markdownIt-Anchor" href="#习题1-7-年份year"></a> 习题1-7 年份（year）</h2><h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3><p>输入年份，判断是否为闰年。如果是，则输出yes，否则输出no。<br />提示：简单地判断除以4的余数是不够的。</p><h3 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>)) || (year % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闰年判断方法：四年一闰，百年不闰，四百年再闰。<br />也就是说：</p><ul><li>如果年份能被4整除且不能被100整除，则是闰年。</li><li>如果年份能被400整除，则是闰年。</li><li>否则不是闰年。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>至此，我们已经完成了《算法竞赛入门经典》第一章的习题解析。通过这一章的基础训练，相信你对编程竞赛的思维模式和代码规范有了更深的体会。算法竞赛的旅途从来不是一蹴而就的，每一个正确通过的测试用例、每一个优化掉的超时边界、每一个恍然大悟的解题思路，都是你在这条路上留下的坚实脚印。</p><p>在后续章节中，我们会逐步深入数据结构、动态规划、图论等核心领域，但请始终牢记：扎实的基础和反复的实践是应对复杂问题的基石。如果在后续学习中遇到瓶颈，不妨回头重新审视这些基础问题，往往会有新的启发。</p><p>愿你在不断调试代码与思维的过程中，感受到算法之美与编程之乐。下一章，我们不见不散！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 1-4（鸡兔同笼）</title>
      <link href="/2025/02/22/%E4%BE%8B%E9%A2%981-4/"/>
      <url>/2025/02/22/%E4%BE%8B%E9%A2%981-4/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-1-4鸡兔同笼"><a class="markdownIt-Anchor" href="#算法入门经典-例题-1-4鸡兔同笼"></a> 算法入门经典 例题 1-4（鸡兔同笼）</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>鸡和兔总数量为 n，总腿数为 m。输入 n 和 m，依次输出鸡的数目和兔的数目。若无解，那么输出 No answer。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>这里开始上难度，但是鸡兔同笼是小学学的。。。</p><p>定义变量 j、t，分别表示鸡的数量、兔子的数量。</p><p>先来写出两个关系式：</p><ul><li>j + t = n</li><li>2j + 4t = m</li></ul><p>代入消元</p><ul><li>t = (m-2n)/2</li></ul><p>所以</p><ul><li>j = n – t</li></ul><p>并且，我们也要考虑，输入的 m、n 必须为正整数。</p><p>那么，我们可以写出以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n:总数量</span></span><br><span class="line"><span class="comment">    m:总腿数</span></span><br><span class="line"><span class="comment">    j:鸡数量</span></span><br><span class="line"><span class="comment">    t:兔数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> m,n,j,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    t = (m - <span class="number">2</span> * n) / <span class="number">2</span>;</span><br><span class="line">    j = n - t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> != <span class="number">0</span> || m &lt; <span class="number">2</span> * n || m &gt; <span class="number">4</span> * n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No answer&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体难度也不高。</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 1-3</title>
      <link href="/2025/02/22/%E4%BE%8B%E9%A2%981-3/"/>
      <url>/2025/02/22/%E4%BE%8B%E9%A2%981-3/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-1-3"><a class="markdownIt-Anchor" href="#算法入门经典-例题-1-3"></a> 算法入门经典 例题 1-3</h1><p>算法是思想的体操，竞赛是智慧的碰撞。</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>输入两个整数 a 和 b，交换二者的值，然后输出。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>这一个例题甚至比上一个简单，解法直接使用经典的“三变量法”就行了。</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    a = n;</span><br><span class="line">    n = m;</span><br><span class="line">    m = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过！</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 1-2</title>
      <link href="/2025/02/21/%E4%BE%8B%E9%A2%981-2/"/>
      <url>/2025/02/21/%E4%BE%8B%E9%A2%981-2/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-1-2"><a class="markdownIt-Anchor" href="#算法入门经典-例题-1-2"></a> 算法入门经典 例题 1-2</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>输入一个三位数，分离出它的百位、十位和个位，反转后输出。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>其实题目也很简单，难点在于如何分离出它百位、十位和个位。</p><ul><li>百位 = n/100</li><li>十位 = n/10%10</li><li>个位 = n%10</li></ul><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exchange</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hundred,ten,one,a;</span><br><span class="line">    hundred = n / <span class="number">100</span>;</span><br><span class="line">    ten = n / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">    one = n %  <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    a = one * <span class="number">100</span> + ten * <span class="number">10</span> + hundred;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="built_in">exchange</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次也是认真多了，一遍过。</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法入门经典 例题 1-1</title>
      <link href="/2025/02/21/%E4%BE%8B%E9%A2%981-1/"/>
      <url>/2025/02/21/%E4%BE%8B%E9%A2%981-1/</url>
      
        <content type="html"><![CDATA[<h1 id="算法入门经典-例题-1-1"><a class="markdownIt-Anchor" href="#算法入门经典-例题-1-1"></a> 算法入门经典 例题 1-1</h1><p>好的，从今天开始，我将学习刘汝佳老师的《算法竞赛入门经典》，以便冲刺今年九月份的 CSP-J。</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>输入底面半径 r 和高 h，输出圆柱体的表面积，保留3位小数。</p><h3 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Area = 274.889</span><br></pre></td></tr></table></figure><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>由于题目过于简单，上过小学的人都会逻辑，所以没有分析。</p><h3 id="初版解答"><a class="markdownIt-Anchor" href="#初版解答"></a> 初版解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">(r,h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    s = <span class="number">2</span> * pi * r ** <span class="number">2</span> + <span class="number">2</span> * pi * r * h;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r,h,a;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; r &gt;&gt; h;</span><br><span class="line">    a = <span class="built_in">area</span>(r,h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area = &quot;</span> &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大意了，这个程序存在以下问题：</p><ol><li><p><strong>参数类型缺失</strong></p><p><code>float area(r,h)</code> 未声明参数类型。</p></li><li><p><strong>未定义常量 π</strong></p><p>C++ 标准库中没有预定义的 <code>pi</code>。</p></li><li><p><strong>错误的幂运算符</strong></p><p>C++ 不支持 <code>**</code> 运算符。</p></li><li><p><strong>变量类型不匹配</strong></p></li><li><p><strong>公式优化</strong></p></li></ol><p>这个故事告诉我们：</p><blockquote><p>不要以为语言入门之后就能轻易地写出算法程序。<br />——《算法竞赛入门经典》前言</p></blockquote><p>这也是我以前存在的问题。</p><h3 id="修改解答"><a class="markdownIt-Anchor" href="#修改解答"></a> 修改解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">(<span class="type">float</span> r,<span class="type">float</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> s,pi;</span><br><span class="line">    pi = <span class="number">3.1415926</span>;</span><br><span class="line">    s = <span class="number">2</span> * pi * r * r + <span class="number">2</span> * pi * r * h;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> r,h,a;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; r &gt;&gt; h;</span><br><span class="line">    a = <span class="built_in">area</span>(r,h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area = &quot;</span> &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美通过</p><p>收工！</p><p>祝各位读者早日成为神牛牪犇！</p>]]></content>
      
      
      <categories>
          
          <category> 《算法竞赛入门经典》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2025/02/18/STL/"/>
      <url>/2025/02/18/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h1><p>STL（Standard Template Library，标准模板库）是 C++ 标准库的一部分，提供了一组通用的、可重用的模板类和算法，用于处理常见的数据结构和操作。STL 通过提供高效、抽象和灵活的代码，使开发者能够更快速地实现常见的数据操作，而无需从头开始编写底层实现。</p><p>STL 的核心包括三部分：</p><ul><li><strong>容器（Containers）</strong>：用于存储和管理数据的对象。</li><li><strong>算法（Algorithms）</strong>：用于操作容器数据的函数。</li><li><strong>迭代器（Iterators）</strong>：用于遍历容器的对象，类似于指针。</li><li><strong>函数对象（Function Objects）</strong>：即可调用的对象，通常与算法结合使用。</li></ul><h2 id="stl-的主要组成部分"><a class="markdownIt-Anchor" href="#stl-的主要组成部分"></a> STL 的主要组成部分：</h2><h3 id="1-容器containers"><a class="markdownIt-Anchor" href="#1-容器containers"></a> 1. 容器（Containers）</h3><p>容器是用于存储数据的对象，它们通过提供不同的结构（如数组、链表、哈希表等）来管理数据。STL 提供了多种容器，主要分为以下几类：</p><ul><li><strong>顺序容器（Sequence Containers）</strong>：<ul><li>这些容器按顺序存储元素，元素的位置由其在容器中的位置决定。</li><li>常见的顺序容器包括：<ul><li><code>vector</code>：动态数组，支持快速随机访问和尾部插入/删除。</li><li><code>deque</code>：双端队列，支持在两端进行高效的插入和删除。</li><li><code>list</code>：双向链表，支持高效的在两端进行插入和删除，但不支持快速随机访问。</li><li><code>array</code>：固定大小的数组，大小在编译时确定，提供常数时间的元素访问。</li></ul></li></ul></li><li><strong>关联容器（Associative Containers）</strong>：<ul><li>这些容器根据元素的键值对存储元素，并支持高效的键查找。</li><li>常见的关联容器包括：<ul><li><code>set</code>：集合，不允许重复元素，自动排序。</li><li><code>map</code>：映射，存储键值对（key-value），键不重复，自动排序。</li><li><code>multiset</code>：多重集合，允许重复元素，自动排序。</li><li><code>multimap</code>：多重映射，允许键重复，自动排序。</li></ul></li></ul></li><li><strong>无序容器（Unordered Containers）</strong>：<ul><li>这些容器基于哈希表实现，提供常数时间的查找操作，但元素没有顺序。</li><li>常见的无序容器包括：<ul><li><code>unordered_set</code>：无序集合，基于哈希表存储元素。</li><li><code>unordered_map</code>：无序映射，基于哈希表存储键值对。</li></ul></li></ul></li></ul><h3 id="2-算法algorithms"><a class="markdownIt-Anchor" href="#2-算法algorithms"></a> 2. 算法（Algorithms）</h3><p>STL 提供了大量的算法，涵盖了排序、查找、修改等常见操作。STL 算法是泛型的，即它们可以与任何符合要求的容器配合使用。常见的算法包括：</p><ul><li>排序算法：<code>sort</code>、<code>stable_sort</code>、<code>partial_sort</code> 等。</li><li>查找算法：<code>find</code>、<code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code> 等。</li><li>修改算法：<code>reverse</code>、<code>rotate</code>、<code>swap</code> 等。</li><li>数值算法：<code>accumulate</code>、<code>count</code>、<code>fill</code> 等。</li><li>集合操作：<code>set_union</code>、<code>set_intersection</code>、<code>set_difference</code> 等。</li></ul><p>这些算法通常都接受迭代器作为参数，使它们与各种容器兼容。</p><h3 id="3-迭代器iterators"><a class="markdownIt-Anchor" href="#3-迭代器iterators"></a> 3. 迭代器（Iterators）</h3><p>迭代器是 STL 中用于遍历容器的对象，它们可以看作是容器的指针。通过迭代器，算法可以访问容器中的元素，而不关心容器的具体实现。迭代器的类型有：</p><ul><li>输入迭代器（Input Iterator）：只能进行单向读取。</li><li>输出迭代器（Output Iterator）：只能进行单向写入。</li><li>前向迭代器（Forward Iterator）：可以进行多次读取和写入，支持双向遍历。</li><li>双向迭代器（Bidirectional Iterator）：除了前向迭代，还可以进行反向迭代。</li><li>随机访问迭代器（Random Access Iterator）：支持随机访问，可以直接跳转到容器中的任何位置。</li></ul><h3 id="4-函数对象function-objects"><a class="markdownIt-Anchor" href="#4-函数对象function-objects"></a> 4. 函数对象（Function Objects）</h3><p>函数对象是实现了 <code>operator()</code> 的对象，它们可以像普通函数一样被调用。STL 算法广泛使用函数对象来指定排序规则、判断条件等。例如：</p><ul><li><code>greater&lt;T&gt;</code>：函数对象，用于比较元素的大小，通常用于降序排序。</li><li><code>less&lt;T&gt;</code>：函数对象，用于比较元素的大小，通常用于升序排序。</li></ul><h2 id="常见的-stl-容器示例"><a class="markdownIt-Anchor" href="#常见的-stl-容器示例"></a> 常见的 STL 容器示例：</h2><h3 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1. <code>vector</code></h3><p><code>vector</code> 是一个动态数组，可以动态扩展大小，提供高效的随机访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">6</span>); <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-map"><a class="markdownIt-Anchor" href="#2-map"></a> 2. <code>map</code></h3><p><code>map</code> 是一个有序的键值对容器，键是唯一的，并且自动排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; age;</span><br><span class="line">    age[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    age[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    age[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-set"><a class="markdownIt-Anchor" href="#3-set"></a> 3. <code>set</code></h3><p><code>set</code> 是一个有序的集合，不允许重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出：1 3 4 5 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stl-的优缺点"><a class="markdownIt-Anchor" href="#stl-的优缺点"></a> STL 的优缺点：</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h3><ul><li><strong>高效性</strong>：STL 容器和算法经过高度优化，通常能提供良好的时间和空间效率。</li><li><strong>泛型编程</strong>：STL 是基于模板的，可以与任意类型的容器配合使用，增加了代码的重用性。</li><li><strong>灵活性和抽象性</strong>：STL 提供了丰富的容器、算法和迭代器，支持多种数据结构和操作的组合。</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h3><ul><li><strong>学习曲线</strong>：对于初学者来说，理解模板和泛型编程的概念可能比较困难。</li><li><strong>调试复杂性</strong>：STL 的错误通常比较隐蔽，尤其是使用复杂的模板时，调试信息可能较难解读。</li><li><strong>性能过度抽象</strong>：某些情况下，STL 容器和算法的抽象可能会导致性能损失，尤其是在对性能要求极高的场景中。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p>STL（标准模板库）为 C++ 提供了一组丰富的、经过优化的数据结构和算法，使得开发者能够快速高效地解决各种常见问题。通过使用容器、算法和迭代器，STL 提供了高抽象级别的编程方式，同时也保持了灵活性和性能优势。</p>]]></content>
      
      
      <categories>
          
          <category> C++语言学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vector 向量</title>
      <link href="/2025/02/18/vector%E5%90%91%E9%87%8F/"/>
      <url>/2025/02/18/vector%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="vector-向量"><a class="markdownIt-Anchor" href="#vector-向量"></a> Vector 向量</h1><p><code>Vector</code> 是一种<strong>动态数组</strong>，属于 STL 中的容器类之一，它提供了可以自动扩展大小的数组功能。与传统的数组不同，<code>Vector</code> 在需要时会自动调整大小，且支持快速访问、插入、删除等操作。</p><h2 id="vector-的特点"><a class="markdownIt-Anchor" href="#vector-的特点"></a> Vector 的特点：</h2><ul><li><strong>动态大小</strong>：<code>Vector</code> 的大小是动态变化的，可以根据需要自动增长或缩小，避免了固定大小数组的限制。</li><li><strong>按索引访问</strong>：可以像数组一样使用索引来访问 <code>Vector</code> 中的元素。</li><li><strong>存储效率</strong>：<code>Vector</code> 会根据需要自动调整内部存储的大小，通常会预留一些额外空间来减少频繁的内存重新分配。</li><li><strong>随机访问</strong>：支持快速随机访问，时间复杂度为 O(1)，就像数组一样。</li><li><strong>支持常见操作</strong>：<code>Vector</code> 提供了许多常见的操作，如插入、删除、查找、排序等。</li></ul><h2 id="vector-的优点"><a class="markdownIt-Anchor" href="#vector-的优点"></a> Vector 的优点：</h2><ul><li><strong>灵活性</strong>：不需要事先知道容器的大小，可以动态调整。</li><li><strong>效率</strong>：与数组相比，<code>Vector</code> 在元素插入和删除时表现更好，尤其是插入到末尾时。</li><li><strong>内存管理</strong>：<code>Vector</code> 会根据需要自动调整内部容量，减少了内存浪费。</li></ul><h2 id="vector-的缺点"><a class="markdownIt-Anchor" href="#vector-的缺点"></a> Vector 的缺点：</h2><ul><li><strong>在中间插入和删除效率低</strong>：虽然插入和删除操作通常很高效，但在 <code>Vector</code> 中间插入或删除元素时，可能需要移动大量的元素，时间复杂度为 O(n)。</li><li><strong>内存重新分配</strong>：当 <code>Vector</code> 需要扩展容量时，它会分配一个新的更大的数组，并将元素复制到新的位置，这个过程可能会影响性能，尤其是元素较多时。</li></ul><h2 id="vector-的常见操作"><a class="markdownIt-Anchor" href="#vector-的常见操作"></a> Vector 的常见操作：</h2><ul><li><strong>访问元素</strong>：使用索引或迭代器访问元素。</li><li><strong>插入元素</strong>：可以在末尾插入元素，或者在指定位置插入。</li><li><strong>删除元素</strong>：可以删除指定位置的元素，或者删除末尾的元素。</li><li><strong>查找元素</strong>：可以使用 <code>find</code> 等函数查找元素。</li></ul><h2 id="示例c"><a class="markdownIt-Anchor" href="#示例c"></a> 示例（C++）：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// 引入vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在末尾插入元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">// 插入10</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>); <span class="comment">// 插入20</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>); <span class="comment">// 插入30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; endl;   <span class="comment">// 输出: 10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二个元素: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除末尾元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>(); <span class="comment">// 删除30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历vector</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vector中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 10 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">15</span>); <span class="comment">// 在第二个位置插入15</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入15后的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 10 15 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析：</h3><ul><li><code>push_back</code>：将元素添加到 <code>Vector</code> 的末尾。</li><li><code>vec[0]</code> 或 <code>vec.at(1)</code>：通过索引或 <code>at</code> 方法访问元素，at 方法会进行越界检查。</li><li><code>pop_back</code>：删除 <code>Vector</code> 末尾的元素。</li><li><code>insert</code>：在指定位置插入元素，<code>vec.begin() + 1</code> 表示第二个位置。</li></ul><h2 id="vector-的应用"><a class="markdownIt-Anchor" href="#vector-的应用"></a> Vector 的应用：</h2><ul><li><strong>动态数组</strong>：<code>Vector</code> 主要用于处理不知道大小的动态数据集合，且需要快速随机访问和插入删除操作。</li><li><strong>实现其他数据结构</strong>：<code>Vector</code> 可以用来实现栈、队列等数据结构。例：栈可以用 <code>push_back</code> 添加元素，使用 <code>pop_back</code> 删除元素。</li><li><strong>数据存储</strong>：适用于存储需要动态增加或删除元素的场景，如图像数据、传感器数据等。</li><li><strong>算法优化</strong>：由于 <code>Vector</code> 支持高效的随机访问，它常用于一些需要按位置访问元素的算法，如快速排序、查找算法等。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p><code>Vector</code> 是一个灵活且高效的动态数组容器，广泛应用于需要动态管理数据的场景。相比传统数组，它提供了更好的内存管理和扩展能力，适用于频繁添加元素的场合。</p><p>在使用 <code>Vector</code> 时，需要注意插入删除中间元素的性能问题，并根据具体情况选择合适的数据结构。如果你需要频繁在中间插入或删除元素，链表可能是一个更好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> C++语言学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树 Binary Tree</title>
      <link href="/2025/02/18/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/"/>
      <url>/2025/02/18/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-binary-tree"><a class="markdownIt-Anchor" href="#二叉树-binary-tree"></a> 二叉树 Binary Tree</h1><p>二叉树是一种每个节点最多有两个子节点的树形数据结构。它是一种广泛应用于计算机科学中的数据结构，常用于表达层次结构、实现查找、排序、表达式求值等任务。</p><h2 id="二叉树的基本定义"><a class="markdownIt-Anchor" href="#二叉树的基本定义"></a> 二叉树的基本定义：</h2><ul><li><strong>节点</strong>：二叉树中的每个元素，通常包含数据和指向其子节点的指针。</li><li><strong>根节点（Root）</strong>：二叉树的第一个节点，是树的起点。</li><li><strong>子节点（Children）</strong>：每个节点可以有最多两个子节点，分别是左子节点和右子节点。</li><li><strong>叶节点（Leaf）</strong>：没有任何子节点的节点，也叫终端节点。</li><li><strong>父节点（Parent）</strong>：指向某一节点的上级节点。</li><li><strong>深度（Depth）</strong>：从根节点到该节点的路径长度。</li><li><strong>高度（Height）</strong>：从该节点到最远叶子节点的路径长度。</li></ul><h2 id="二叉树的基本类型"><a class="markdownIt-Anchor" href="#二叉树的基本类型"></a> 二叉树的基本类型</h2><ol><li><strong>满二叉树（Full Binary Tree）</strong>：<ul><li>每个节点要么没有子节点，要么有两个 子节点。</li><li>即，除了叶节点外，其他每个节点都有两个子节点。</li></ul></li><li><strong>完全二叉树（Complete Binary Tree）</strong>：<ul><li>除了最后一层外，每一层的节点都尽可能多，且最后一层的节点都集中在左侧。</li></ul></li><li><strong>平衡二叉树（Balanced Binary Tree）</strong>：<ul><li>任意节点的左右子树的高度差不超过 1。</li><li>例如，AVL树和红黑树是常见的平衡二叉树。</li></ul></li><li><strong>二叉搜索树（Binary Search Tree, BST）</strong>：<ul><li>对于树中的每一个节点，左子树的所有节点的值小于该节点的值，右子树的所有节点的值大于该节点的值。</li><li>二叉搜索树提供了高效的查找、插入和删除操作。</li></ul></li><li><strong>赫夫曼树（Huffman Tree）</strong>：<ul><li>一种带权路径长度最短的二叉树，常用于数据压缩算法中。</li></ul></li></ol><h2 id="二叉树的基本操作"><a class="markdownIt-Anchor" href="#二叉树的基本操作"></a> 二叉树的基本操作</h2><p>二叉树的操作主要包括遍历、插入、删除、查找等。下面介绍常见的操作：</p><h4 id="1-遍历traversal"><a class="markdownIt-Anchor" href="#1-遍历traversal"></a> 1. <strong>遍历（Traversal）</strong></h4><p>遍历是指按照一定的顺序访问二叉树的每个节点。常见的遍历方式有：</p><ul><li><strong>前序遍历（Pre-order Traversal）</strong>：访问根节点，然后递归遍历左子树和右子树。<ul><li>顺序：根 → 左 → 右</li><li>示例：<code>A, B, D, E, C, F</code></li></ul></li><li><strong>中序遍历（In-order Traversal）</strong>：递归遍历左子树，然后访问根节点，最后递归遍历右子树。<ul><li>顺序：左 → 根 → 右</li><li>示例：<code>D, B, E, A, F, C</code></li></ul></li><li><strong>后 序遍历（Post-order Traversal）</strong>：递归遍历左子树和右子树，然后访问根节点。<ul><li>顺序：左 → 右 → 根</li><li>示例：<code>D, E, B, F, C, A</code></li></ul></li><li><strong>层次遍历（Level-order Traversal）</strong>：逐层遍历树的节点，通常使用队列实现。<ul><li>顺序：从根节点开始，逐层访问每个节点。</li><li>示例：<code>A, B, C, D, E, F</code></li></ul></li></ul><h4 id="2-插入insertion"><a class="markdownIt-Anchor" href="#2-插入insertion"></a> 2. <strong>插入（Insertion）</strong></h4><ul><li><strong>二叉搜索树的插入</strong>：在二叉搜索树中插入节点时，根据节点的值与当前节点的值进行比较，决定将新节点插入到左子树还是右子树，直到找到合适的位置。</li></ul><h4 id="3-删除deletion"><a class="markdownIt-Anchor" href="#3-删除deletion"></a> 3. <strong>删除（Deletion）</strong></h4><ul><li><strong>删除节点</strong>：删除二叉树中的节点时，需要考虑三种情况：<ul><li><strong>没有子节点</strong>（叶节点）：直接删除。</li><li><strong>有一个子节点</strong>：用子节点替代被删除的节点。</li><li><strong>有两个子节点</strong>：通常用右子树中的最小节点或左子树中的最大节点来替代被删除的节点，然后递归删除替代节点。</li></ul></li></ul><h4 id="4-查找search"><a class="markdownIt-Anchor" href="#4-查找search"></a> 4. <strong>查找（Search）</strong></h4><ul><li><strong>二叉搜索树的查找</strong>：从根节点开始，根据查找的值与当前节点的值比较，决定是向左子树还是右子树查找，直到找到该节点或遍历完整棵树。</li></ul><h3 id="二叉树的应用"><a class="markdownIt-Anchor" href="#二叉树的应用"></a> 二叉树的应用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     *</span><br><span class="line">    / \</span><br><span class="line">  +   +</span><br><span class="line"> / \  / \</span><br><span class="line">a   b c   d</span><br></pre></td></tr></table></figure><ol><li><strong>表达式树</strong>：用于表示数学表达式。在计算机科学中，表达式树是二叉树的一种应用，其中每个叶子节点代表操作数，每个非叶子节点代表操作符。<ul><li>例如：<code>(a + b) * (c + d)</code> 可以表示为以上代码块。</li></ul></li><li><strong>二叉查找树的应用</strong>：<ul><li><strong>高效查找</strong>：在二叉查找树中，查找操作的平均时间复杂度是 O(log n)，比线性查找 O(n) 更高效。</li><li><strong>排序</strong>：通过中序遍历二叉搜索树可以得到一个有序序列，从而实现排序。</li></ul></li><li><strong>堆（Heap）</strong>：<ul><li><strong>二叉堆</strong>是一种特殊的二叉树，常用于实现优先队列。二叉堆有两种：最大堆和最小堆。最大堆的父节点的值大于等于子节点的值，最小堆则相反。</li></ul></li><li><strong>二叉树的平衡</strong>：AVL 树、红黑树等自平衡二叉树可以用于实现高效的查找、插入和删除操作，广泛应用于数据库索引、内存管理等领域。</li></ol><h3 id="二叉树的优缺点"><a class="markdownIt-Anchor" href="#二叉树的优缺点"></a> 二叉树的优缺点：</h3><p><strong>优点</strong>：</p><ul><li><strong>结构简单</strong>：二叉树结构简单，易于理解和实现。</li><li><strong>查找效率高</strong>：对于平衡的二叉搜索树（如 AVL 树、红黑树），其查找、插入、删除操作的平均时间复杂度是 O(log n)，相比线性数据结构更高效。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不平衡会导致效率降低</strong>：如果二叉树不平衡（例如退化成链表），则查找、插入、删除的时间复杂度将变为 O(n)。</li><li><strong>空间开销较大</strong>：每个节点需要存储指向左右子节点的指针，相较于一些线性数据结构，空间开销较大。</li></ul><h3 id="二叉树的实现示例c"><a class="markdownIt-Anchor" href="#二叉树的实现示例c"></a> 二叉树的实现示例（C++）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode* left;  <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode* right;  <span class="comment">// 右子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);  <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);  <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);  <span class="comment">// 遍历右子树</span></span><br><span class="line">    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一棵二叉树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析：</h3><ol><li><strong>TreeNode</strong>：定义了一个二叉树节点结构，包含节点值、左子节点和右子节点。</li><li><strong>preorder</strong>、<strong>inorder</strong>、<strong>postorder</strong>：分别是前序、中序、后序遍历的递归实现。</li><li><strong>main</strong>：在主函数中构建了一个简单的二叉树，并进行遍历。</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>二叉树是一种非常基础且重要的树形数据结构，广泛应用于各种算法和系统中。它具有良好的灵活性和扩展性，可以支持不同的变种，如二叉搜索树、AVL 树、红黑树等，能够有效地提升查找、插入和删除操作的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表 Hash Table</title>
      <link href="/2025/02/18/%E5%93%88%E5%B8%8C%E8%A1%A8-Hash-Table/"/>
      <url>/2025/02/18/%E5%93%88%E5%B8%8C%E8%A1%A8-Hash-Table/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表-hash-table"><a class="markdownIt-Anchor" href="#哈希表-hash-table"></a> 哈希表 Hash Table</h1><p>哈希表（Hash Table）是一种用于存储键值对（key-value pairs）的数据结构，它可以实现非常高效的查找、插入和删除操作。哈希表通过哈希函数将键映射到哈希表的索引位置，从而能在常数时间 O(1) 内完成查找、插入和删除操作。</p><h2 id="哈希表的基本原理"><a class="markdownIt-Anchor" href="#哈希表的基本原理"></a> 哈希表的基本原理</h2><ol><li><strong>哈希函数</strong>：哈希表通过哈希函数将键（key）映射到哈希表中的一个特定位置（即索引）。哈希函数的目标是尽可能将不同的键映射到不同的索引，以减少冲突。<ul><li>哈希函数的一种常见实现方法是：<code>hash(key) = key % table_size</code>，这里的 <code>table_size</code> 是哈希表的大小。</li></ul></li><li><strong>冲突（Collision）</strong>：不同的键可能通过哈希函数计算后得到相同的哈希值，从而映射到同一个位置，这时就发生了冲突。解决冲突的常见方法有：<ul><li><strong>链式地址法（Separate Chaining）</strong>：每个哈希表的槽位（bucket）存储一个链表，冲突的元素存储在同一个链表中。</li><li><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，哈希表会尝试在表中寻找其他空位，直到找到一个空槽。</li></ul></li><li><strong>负载因子（Load Factor）</strong>：负载因子是哈希表中的元素数量与哈希表大小的比值，用来衡量哈希表的填充程度。负载因子过高可能导致哈希冲突增多，从而降低性能。通常当负载因子超过某个阈值时，会对哈希表进行扩容（rehash）。</li><li><strong>扩容与再哈希（Rehashing）</strong>：当哈希表的负载因子超过设定的阈值时，可以通过增加哈希表的大小并重新计算每个元素的哈希值来减少冲突，从而提高查找效率。</li></ol><h2 id="哈希表的基本操作"><a class="markdownIt-Anchor" href="#哈希表的基本操作"></a> 哈希表的基本操作</h2><ol><li><strong>插入（Insert）</strong>：<ul><li>使用哈希函数计算键的哈希值，并将其映射到对应的槽位。</li><li>如果槽位已被占用，则根据解决冲突的方法（链式或开放定址法）处理冲突。</li></ul></li><li><strong>查找（Search）</strong>：<ul><li>使用哈希函数计算键的哈希值，然后检查该槽位是否存在对应的值。如果有冲突，则需要继续检查链表或其他空槽。</li></ul></li><li><strong>删除（Delete）</strong>：<ul><li>使用哈希函数找到元素的位置，并删除它。如果存在冲突（如链式法），需要相应地删除链表中的元素。</li></ul></li><li><strong>扩容（Rehashing）</strong>：<ul><li>当哈希表的负载因子过高时，哈希表的大小需要扩大，通常是扩展为原来大小的两倍，然后重新计算每个元素的哈希值并重新插入。</li></ul></li></ol><h2 id="哈希表的优缺点"><a class="markdownIt-Anchor" href="#哈希表的优缺点"></a> 哈希表的优缺点</h2><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h4><ul><li><strong>快速查找</strong>：在理想情况下，哈希表的查找、插入和删除操作的时间复杂度是 O(1)，即常数时间操作。</li><li><strong>高效存储</strong>：由于哈希表通过哈希函数直接映射到槽位，因此可以在大规模数据存储时提供高效的访问。</li></ul><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h4><ul><li><strong>哈希冲突</strong>：当多个键映射到同一个位置时，会发生哈希冲突。虽然可以通过链式或开放定址法解决冲突，但会影响操作效率。</li><li><strong>不适合排序</strong>：哈希表中的元素没有顺序，不能直接支持按键排序。</li><li><strong>空间开销</strong>：哈希表为了避免过多冲突，通常需要比实际存储元素更多的空间。这可能导致内存浪费。</li></ul><h2 id="哈希表的应用"><a class="markdownIt-Anchor" href="#哈希表的应用"></a> 哈希表的应用</h2><ol><li><strong>快速查找</strong>：哈希表用于实现快速查找功能，广泛应用于数据库索引、缓存系统等。</li><li><strong>去重</strong>：通过将元素作为键存储，哈希表可以方便地去除重复元素。例如，在处理大数据时，通过哈希表去除重复记录。</li><li><strong>计数统计</strong>：哈希表可以用于统计每个元素出现的次数，广泛应用于词频统计、数据分析等。</li><li><strong>实现集合操作</strong>：哈希表常常用于实现集合（set）的操作，如交集、并集、差集等。</li></ol><h2 id="哈希表的示例实现c"><a class="markdownIt-Anchor" href="#哈希表的示例实现c"></a> 哈希表的示例实现（C++）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; table;  <span class="comment">// 哈希表的桶（使用链表处理冲突）</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 哈希表的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;  <span class="comment">// 哈希函数（取模）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">int</span> s) &#123;</span><br><span class="line">        size = s;</span><br><span class="line">        table.<span class="built_in">resize</span>(s);  <span class="comment">// 初始化哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);  <span class="comment">// 计算哈希值</span></span><br><span class="line">        table[index].<span class="built_in">push_back</span>(key);  <span class="comment">// 在对应的槽位插入键</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> element : table[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未找到元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">remove</span>(key);  <span class="comment">// 从链表中删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Bucket &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> element : table[i]) &#123;</span><br><span class="line">                cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HashTable <span class="title">ht</span><span class="params">(<span class="number">7</span>)</span></span>;  <span class="comment">// 创建一个大小为7的哈希表</span></span><br><span class="line">    </span><br><span class="line">    ht.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    ht.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    ht.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    ht.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    ht.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    ht.<span class="built_in">display</span>();  <span class="comment">// 显示哈希表</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Search 15: &quot;</span> &lt;&lt; (ht.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Search 25: &quot;</span> &lt;&lt; (ht.<span class="built_in">search</span>(<span class="number">25</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    ht.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After deleting 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ht.<span class="built_in">display</span>();  <span class="comment">// 删除元素后显示哈希表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析</h2><ol><li><strong>HashTable 类</strong>：包含了哈希表的基本操作，如插入、查找、删除和显示哈希表。</li><li><strong>insert()</strong>：通过哈希函数计算插入元素的槽位，然后将元素插入到该槽位的链表中。</li><li><strong>search()</strong>：通过哈希函数找到槽位后，遍历链表检查是否有该元素。</li><li><strong>remove()</strong>：通过哈希函数找到槽位，并从该槽位的链表中删除元素。</li><li><strong>display()</strong>：显示哈希表的所有槽位及其存储的元素。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>哈希表是一种高效的键值对存储数据结构，能够提供常数时间复杂度的查找、插入和删除操作。它广泛应用于需要高效查找、去重和计数的场景。虽然哈希表在实际应用中需要解决哈希冲突问题，但通过合适的冲突解决方法，可以保证其高效性。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组 array</title>
      <link href="/2025/02/18/%E6%95%B0%E7%BB%84array/"/>
      <url>/2025/02/18/%E6%95%B0%E7%BB%84array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-array"><a class="markdownIt-Anchor" href="#数组-array"></a> 数组 array</h1><h2 id="数组的特点"><a class="markdownIt-Anchor" href="#数组的特点"></a> 数组的特点：</h2><ol><li><strong>固定大小</strong>：数组在创建时必须指定大小，一旦定义，大小不能更改。这意味着，如果需要存储更多的数据，必须创建一个新的数组并复制数据。</li><li><strong>元素类型相同</strong>：数组中的所有元素必须是相同类型的数据（如整数、字符、浮点数等）。</li><li><strong>按索引访问</strong>：数组的每个元素都有一个唯一的索引，索引从0开始，允许直接访问任何元素。</li><li><strong>连续内存</strong>：数组的元素在内存中是连续存储的，这使得数组具有较快的访问速度。</li></ol><h2 id="数组的缺点"><a class="markdownIt-Anchor" href="#数组的缺点"></a> 数组的缺点：</h2><ol><li><strong>固定大小</strong>：数组一旦创建，其大小是固定的，无法动态扩展。如果数据量超出了原先设定的大小，必须重新分配更大的数组并复制数据，效率较低。</li><li><strong>浪费内存</strong>：如果你事先定义的数组大小过大，可能会浪费内存空间；如果大小过小，可能会导致无法存储所有数据。</li><li><strong>插入和删除效率低</strong>：数组中的元素是连续存储的，因此在数组中间插入或删除元素时，需要移动大量的数据，效率较低。</li></ol><h2 id="示例c"><a class="markdownIt-Anchor" href="#示例c"></a> 示例（C++）：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化一个包含5个整数的数组</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问数组元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组的第一个元素: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数组元素</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">10</span>;  <span class="comment">// 将数组中第三个元素修改为 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出修改后的数组元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;修改后的第三个元素: &quot;</span> &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的操作"><a class="markdownIt-Anchor" href="#数组的操作"></a> 数组的操作：</h3><ol><li><strong>访问元素</strong>：通过索引访问数组中的元素。例如，<code>arr[3]</code> 访问数组 <code>arr</code> 的第四个元素（索引从0开始）。</li><li><strong>修改元素</strong>：通过指定索引修改数组中的元素。例如，<code>arr[1] = 20</code> 将数组中第二个元素的值改为20。</li><li><strong>遍历数组</strong>：通过循环遍历数组中的每个元素。例如，使用 <code>for</code> 循环来访问所有元素。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>数组初始化</strong>：在声明时，你可以通过花括号 <code>&#123;&#125;</code> 初始化数组，或者使用循环动态赋值。</li></ol><h3 id="数组的应用"><a class="markdownIt-Anchor" href="#数组的应用"></a> 数组的应用：</h3><ol><li><strong>存储一组相同类型的数据</strong>：最常见的应用是存储同类型的数据集合，例如学生的成绩、多个传感器的测量值等。<ul><li>例：存储班级学生的数学成绩。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">30</span>];  <span class="comment">// 存储30个学生的成绩</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实现栈和队列</strong>：通过数组可以实现栈（后进先出）和队列（先进先出）的数据结构。<ul><li>例：使用数组来实现一个队列：</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> queue[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>数据处理和分析</strong>：在数据科学和计算机科学中，数组广泛用于存储和处理数据。<ul><li>例：用数组存储每日气温数据，进行温度变化分析。</li></ul></li><li><strong>排序和查找</strong>：数组是许多经典排序和查找算法（如冒泡排序、二分查找）的基础数据结构。<ul><li>例：使用数组进行排序：</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span> - i - <span class="number">1</span>; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>图像处理</strong>：在图像处理中，像素值通常以二维数组的形式存储，用于表示图像中的颜色和亮度。<ul><li>例：一个图像的RGB像素值可以用二维数组表示。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> image[<span class="number">100</span>][<span class="number">100</span>][<span class="number">3</span>];  <span class="comment">// 100x100像素的图像，每个像素有RGB三个值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈 Stack</title>
      <link href="/2025/02/18/%E6%A0%88stack/"/>
      <url>/2025/02/18/%E6%A0%88stack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈-stack"><a class="markdownIt-Anchor" href="#栈-stack"></a> 栈 Stack</h1><p>栈（Stack）是一种线性数据结构，它遵循“后进先出”（LIFO，Last In First Out）原则，即最后加入的元素最先被取出。栈通常用于实现需要“反向”操作的算法和数据结构。</p><h2 id="栈的特点"><a class="markdownIt-Anchor" href="#栈的特点"></a> 栈的特点：</h2><ul><li><strong>后进先出（LIFO）</strong>：栈的访问顺序遵循后进先出的原则，最后插入的元素最先被移除。</li><li><strong>操作限制</strong>：栈只允许在一端进行插入和删除操作，这一端通常被称为栈顶（Top）。</li><li><strong>动态增长</strong>：栈可以根据需要动态地扩展或收缩（对于动态数组实现的栈）。</li><li><strong>存储结构</strong>：栈可以使用数组或链表来实现。</li></ul><h2 id="栈的常见操作"><a class="markdownIt-Anchor" href="#栈的常见操作"></a> 栈的常见操作：</h2><ul><li><strong>push</strong>：将一个元素添加到栈顶。</li><li><strong>pop</strong>：移除栈顶元素，并返回该元素的值。</li><li><strong>peek（或 top）</strong>：查看栈顶元素的值，但不移除它。</li><li><strong>isEmpty</strong>：检查栈是否为空。</li><li><strong>size</strong>：返回栈中元素的个数。</li></ul><h2 id="栈的应用"><a class="markdownIt-Anchor" href="#栈的应用"></a> 栈的应用：</h2><ul><li><strong>递归调用的实现</strong>：计算机的函数调用使用栈来管理函数的调用和返回。当一个函数调用时，它的返回地址和局部变量会被压入栈中，函数执行完毕后从栈中弹出返回地址。</li><li><strong>表达式求值</strong>：栈常用于表达式的求值和解析，特别是在中缀表达式、后缀表达式和前缀表达式的转换和计算中。</li><li><strong>深度优先搜索（DFS）</strong>：栈用于深度优先搜索（DFS）算法，通过栈记录搜索路径，实现图的遍历。</li><li><strong>回溯算法</strong>：在回溯算法中，栈用于记录当前的选择和路径，便于回退到上一步状态。</li></ul><h2 id="栈的示例c"><a class="markdownIt-Anchor" href="#栈的示例c"></a> 栈的示例（C++）：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">// 引入stack头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 创建一个空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// push操作：压栈</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">10</span>); <span class="comment">// 压入10</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">20</span>); <span class="comment">// 压入20</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">30</span>); <span class="comment">// 压入30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// peek操作：查看栈顶元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈顶元素: &quot;</span> &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 输出: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop操作：弹出栈顶元素</span></span><br><span class="line">    st.<span class="built_in">pop</span>(); <span class="comment">// 弹出30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印栈顶元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;弹出栈顶元素后, 栈顶元素: &quot;</span> &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isEmpty操作：检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈不是空的!&quot;</span> &lt;&lt; endl; <span class="comment">// 输出: 栈不是空的!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size操作：获取栈的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈的大小: &quot;</span> &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析：</h3><ul><li><strong>push</strong>：将元素压入栈中。</li><li><strong>top</strong>：查看栈顶元素的值。</li><li><strong>pop</strong>：移除栈顶元素。</li><li><strong>empty</strong>：检查栈是否为空。</li><li><strong>size</strong>：返回栈的元素数量。</li></ul><h2 id="栈的优缺点"><a class="markdownIt-Anchor" href="#栈的优缺点"></a> 栈的优缺点：</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h3><ul><li><strong>时间效率高</strong>：栈的插入和删除操作通常为 O(1) 时间复杂度，因此在许多需要频繁插入和删除操作的场景中，栈非常高效。</li><li><strong>简单的操作</strong>：栈的操作非常简单，只需要知道栈顶元素，并根据栈顶进行插入或删除操作。</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h3><ul><li><strong>访问受限</strong>：栈只允许访问栈顶的元素，不能直接访问栈中的其他元素，因此它并不适用于需要随机访问元素的场景。</li><li><strong>空间限制</strong>：栈的大小是有限的，如果栈中的元素太多，可能会发生栈溢出（尤其是递归调用时，栈空间可能会用尽）。</li></ul><h2 id="栈的应用实例"><a class="markdownIt-Anchor" href="#栈的应用实例"></a> 栈的应用实例：</h2><ul><li><strong>括号匹配</strong>：栈可以用于检测表达式中的括号是否匹配，特别是在编译器中，栈用于解析代码中的括号、花括号、方括号等。</li><li><strong>Undo（撤销）操作</strong>：在许多应用程序中，撤销功能通常是通过栈来实现的，每次执行操作时，将当前状态压入栈中，撤销时从栈中弹出之前的状态。</li><li><strong>表达式求值</strong>：栈用于处理中缀、前缀、后缀表达式的转换和计算。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p>栈是一种常见的线性数据结构，具有后进先出的特点，广泛应用于各种计算机科学和算法问题中。它的简单性和高效性使其成为实现许多算法和数据结构的基础。在需要跟踪状态或执行回溯操作的场景中，栈是非常有用的工具。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表 Linked List</title>
      <link href="/2025/02/18/%E9%93%BE%E8%A1%A8_Linked_List/"/>
      <url>/2025/02/18/%E9%93%BE%E8%A1%A8_Linked_List/</url>
      
        <content type="html"><![CDATA[<h1 id="链表-linked-list"><a class="markdownIt-Anchor" href="#链表-linked-list"></a> 链表 Linked List</h1><p><strong>链表</strong>是一种线性数据结构，它由多个<strong>节点</strong>（Node）组成，每个节点包含<strong>两部分</strong>：</p><ol><li><strong>数据部分</strong>：存储实际的数据。</li><li><strong>指针部分</strong>：存储指向下一个节点的地址。</li></ol><p>链表的结构特点是节点在内存中<strong>不一定是连续存储</strong>的，而是通过指针将一个个节点连接起来。每个节点可以通过指针找到下一个节点，形成一个<strong>链式结构</strong>。</p><h2 id="链表的类型"><a class="markdownIt-Anchor" href="#链表的类型"></a> 链表的类型：</h2><ol><li><strong>单向链表</strong>（Singly Linked List）：每个节点只包含指向下一个节点的指针，最后一个节点的指针指向 <code>null</code>。</li><li><strong>双向链表</strong>（Doubly Linked List）：每个节点包含两个指针，分别指向前一个节点和下一个节点，便于从两端遍历。</li><li><strong>循环链表</strong>（Circular Linked List）：链表的最后一个节点的指针指向第一个节点，形成一个环。</li></ol><h2 id="链表的特点"><a class="markdownIt-Anchor" href="#链表的特点"></a> 链表的特点：</h2><ol><li><strong>动态大小</strong>：链表大小可以动态调整，元素可以随时添加或删除，且不需要提前指定大小。</li><li><strong>插入和删除操作高效</strong>：链表在任何位置的插入和删除都比数组更高效，因为只需要改变指针的指向即可。</li><li><strong>访问不方便</strong>：链表的元素不是连续存储的，访问某个特定元素时需要从头遍历链表，效率较低。</li></ol><h2 id="链表的缺点"><a class="markdownIt-Anchor" href="#链表的缺点"></a> 链表的缺点：</h2><ol><li><strong>随机访问差</strong>：在链表中，访问某个元素需要从头节点开始逐个遍历，无法像数组那样通过索引直接访问，效率较低。</li><li><strong>额外内存开销</strong>：每个节点都需要额外的指针空间，增加了内存的消耗。</li><li><strong>复杂的实现和维护</strong>：链表的插入、删除、遍历等操作涉及到指针操作，相比数组实现较复杂。</li></ol><h2 id="链表的操作"><a class="markdownIt-Anchor" href="#链表的操作"></a> 链表的操作：</h2><ol><li><strong>插入操作</strong>：在链表的任意位置插入一个新节点，需要更新指针的连接。</li><li><strong>删除操作</strong>：删除链表中的某个节点时，更新指针，使其跳过被删除的节点。</li><li><strong>遍历操作</strong>：从头节点开始，顺序访问链表中的所有节点。</li><li><strong>查找操作</strong>：遍历链表查找特定元素（通常时间复杂度是 O(n)）。</li></ol><h2 id="示例c"><a class="markdownIt-Anchor" href="#示例c"></a> 示例（C++）：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;      <span class="comment">// 存储数据</span></span><br><span class="line">    Node* next;    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node*&amp; head, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>();  <span class="comment">// 创建新节点</span></span><br><span class="line">    newNode-&gt;data = value;       <span class="comment">// 设置数据</span></span><br><span class="line">    newNode-&gt;next = head;        <span class="comment">// 新节点指向当前头节点</span></span><br><span class="line">    head = newNode;              <span class="comment">// 更新头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; temp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;  <span class="comment">// 空链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="built_in">insert</span>(head, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">insert</span>(head, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">insert</span>(head, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="built_in">printList</span>(head);  <span class="comment">// 输出: 30 20 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个链表节点 <code>Node</code>，每个节点包含一个 <code>data</code> 数据部分和一个 <code>next</code> 指针，指向下一个节点。通过 <code>insert</code> 函数将元素插入链表头部，并通过 <code>printList</code> 函数遍历链表输出元素。</p><h2 id="链表的应用"><a class="markdownIt-Anchor" href="#链表的应用"></a> 链表的应用：</h2><ol><li><strong>动态内存管理</strong>：链表的动态大小使其适用于内存不确定的场合，常用于实现内存分配器和垃圾回收。</li><li><strong>实现队列和栈</strong>：链表可以用来实现队列（FIFO）和栈（LIFO）数据结构。<ul><li><strong>队列</strong>：使用链表的尾部进行插入，头部进行删除。</li><li><strong>栈</strong>：使用链表的头部进行插入和删除。</li></ul></li><li><strong>图的邻接表</strong>：链表常用于图的邻接表表示，便于存储图中每个节点的邻接节点。</li><li><strong>操作系统进程调度</strong>：链表可以用来实现操作系统的进程调度队列，支持动态添加和删除进程。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><ul><li>链表是灵活、高效的动态数据结构，尤其适用于需要频繁插入和删除操作的场景。但它的缺点是随机访问效率低，并且需要额外的内存来存储指针。</li><li>在实际使用中，链表常用于实现更复杂的数据结构，如队列、栈、图等，也可以作为内存管理的重要工具。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列 Queue</title>
      <link href="/2025/02/18/%E9%98%9F%E5%88%97Queue/"/>
      <url>/2025/02/18/%E9%98%9F%E5%88%97Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="队列-queue"><a class="markdownIt-Anchor" href="#队列-queue"></a> 队列 Queue</h1><p>队列（Queue）是一种线性数据结构，它遵循“先进先出”（FIFO，First In First Out）原则，即第一个进入队列的元素将是第一个被移除的元素。队列的结构像排队的人群，先到的人先得到服务。</p><h3 id="队列的特点"><a class="markdownIt-Anchor" href="#队列的特点"></a> 队列的特点：</h3><ol><li><strong>先进先出（FIFO）</strong>：队列的访问顺序遵循先进先出的原则，最先加入的元素最先被移除。</li><li><strong>操作限制</strong>：队列只允许在一端进行插入操作（称为队尾），只允许在另一端进行删除操作（称为队头）。</li><li><strong>存储结构</strong>：队列可以使用数组或链表来实现。</li></ol><h3 id="队列的常见操作"><a class="markdownIt-Anchor" href="#队列的常见操作"></a> 队列的常见操作：</h3><ol><li><strong>enqueue（入队）</strong>：将元素加入到队列的尾部。</li><li><strong>dequeue（出队）</strong>：从队列的头部移除元素，并返回该元素的值。</li><li><strong>peek（或 front）</strong>：查看队列头部的元素，但不移除它。</li><li><strong>isEmpty</strong>：检查队列是否为空。</li><li><strong>size</strong>：返回队列中元素的个数。</li></ol><h3 id="队列的应用"><a class="markdownIt-Anchor" href="#队列的应用"></a> 队列的应用：</h3><ol><li><strong>任务调度</strong>：操作系统使用队列来管理进程调度。队列用于存放等待执行的任务，系统会按照先进先出的顺序执行这些任务。</li><li><strong>打印队列</strong>：在打印机中，打印任务通常以队列的形式管理。先发出的打印任务先被处理。</li><li><strong>消息队列</strong>：在计算机网络和多线程编程中，消息队列常用来管理不同任务或进程间的通信。消息按照先进先出的顺序进行传递。</li><li><strong>广度优先搜索（BFS）</strong>：广度优先搜索算法（BFS）使用队列来遍历图或树的节点。</li></ol><h3 id="队列的示例c"><a class="markdownIt-Anchor" href="#队列的示例c"></a> 队列的示例（C++）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>  <span class="comment">// 引入queue头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 创建一个空队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// enqueue操作：入队</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 入队10</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 入队20</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 入队30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// peek操作：查看队头元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队头元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue操作：出队</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 出队10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印队头元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队后, 队头元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isEmpty操作：检查队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列不是空的!&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出: 队列不是空的!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size操作：获取队列的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列的大小: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析：</h3><ol><li><code>push</code>：将元素添加到队列的尾部。</li><li><code>front</code>：查看队列头部元素的值。</li><li><code>pop</code>：从队列的头部移除元素。</li><li><code>empty</code>：检查队列是否为空。</li><li><code>size</code>：返回队列中的元素个数。</li></ol><h3 id="队列的优缺点"><a class="markdownIt-Anchor" href="#队列的优缺点"></a> 队列的优缺点：</h3><p><strong>优点</strong>：</p><ul><li><strong>操作简单</strong>：队列的插入和删除操作非常简单且高效。</li><li><strong>顺序性强</strong>：队列适用于需要按顺序处理数据的场景。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>访问受限</strong>：队列只允许访问队头元素，不能随机访问队列中的其他元素。</li><li><strong>空间浪费</strong>：如果使用数组实现队列，可能会出现空间浪费问题，尤其是在元素删除后，队头的位置没有被及时重用（这种情况常见于数组实现的循环队列中）。</li></ul><h3 id="队列的应用实例"><a class="markdownIt-Anchor" href="#队列的应用实例"></a> 队列的应用实例：</h3><ol><li><strong>操作系统中的任务调度</strong>：操作系统在多任务管理中常使用队列来调度任务。任务按照进入队列的顺序依次执行，确保公平性。</li><li><strong>打印任务管理</strong>：多个打印任务进入队列后，打印机按顺序依次处理这些任务。</li><li><strong>广度优先搜索（BFS）</strong>：在图的遍历算法中，BFS利用队列实现对每一层节点的逐层访问，确保先访问靠近起点的节点。</li><li><strong>生产者-消费者问题</strong>：队列可以作为生产者和消费者之间共享缓冲区，生产者将产品放入队列，消费者从队列中取出产品，保证了生产和消费的同步。</li></ol><h3 id="队列的变种"><a class="markdownIt-Anchor" href="#队列的变种"></a> 队列的变种：</h3><ol><li><strong>双端队列（Deque）</strong>：双端队列是可以在两端进行插入和删除操作的队列。它可以作为队列或栈使用，具有更多的灵活性。</li><li><strong>循环队列</strong>：为了避免数组实现队列时出现空间浪费，循环队列利用环形数组结构，当队列的尾部到达数组末端时，会重新使用数组的开头部分。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法题类型</title>
      <link href="/2025/02/05/%E7%AE%97%E6%B3%95%E9%A2%98%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/02/05/%E7%AE%97%E6%B3%95%E9%A2%98%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="算法题类型"><a class="markdownIt-Anchor" href="#算法题类型"></a> 算法题类型</h1><h2 id="1-排序与查找"><a class="markdownIt-Anchor" href="#1-排序与查找"></a> 1. 排序与查找</h2><ul><li><strong>排序问题</strong>：将一组数据按照特定顺序（通常是升序或降序）排列。<ul><li>基础排序：简单直观，适用于小规模数据。<ul><li>冒泡排序：通过不断交换相邻元素进行排序。（<strong>稳定排序</strong>）</li><li>选择排序：每次选择未排序部分的最小元素放到已排序部分的末尾。（<strong>不稳定排序</strong>）</li><li>插入排序：将每个元素插入到已排序部分的正确位置。（<strong>稳定排序</strong>）</li></ul></li><li>高级排序：效率较高，适用于大规模数据。<ul><li>快速排序：通过分治法和基准元素进行排序。（<strong>不稳定排序</strong>）</li><li>归并排序：通过分治法将数据分成小份排序，然后合并。（<strong>稳定排序</strong>）</li><li>堆排序：利用堆这种数据结构进行排序。（<strong>不稳定排序</strong>）</li></ul></li><li>线性排序：时间复杂度为O(n)，适用于特定类型的数据。<ul><li>计数排序：适用于数据范围较小的整数。（<strong>稳定排序</strong>）</li><li>桶排序：将数据分到不同的桶中，然后分别排序。（<strong>稳定排序</strong>）</li><li>基数排序：按位进行排序，适用于整数或字符串。（<strong>稳定排序</strong>）</li></ul></li><li>特殊排序：针对特定场景的排序算法。<ul><li>外部排序：用于处理无法一次性加载到内存的数据。</li></ul></li></ul></li><li><strong>查找问题</strong>：在数据集中寻找特定元素。<ul><li>线性查找：逐个遍历数据，直到找到目标元素。（<strong>时间复杂度O(n)</strong>）</li><li>二分查找：在已排序数据中，通过不断缩小搜索范围来查找目标元素。（<strong>时间复杂度O(log n)</strong>）</li><li>二分查找变种：查找第一个大于等于目标值的元素、查找最后一个小于等于目标值的元素等。</li><li>矩阵中的目标值查找：在二维数组中查找目标元素。</li></ul></li></ul><h2 id="2-数学与数论"><a class="markdownIt-Anchor" href="#2-数学与数论"></a> 2. 数学与数论</h2><ul><li><strong>基础数学</strong>：<ul><li>素数判断：判断一个数是否为素数（只能被1和自身整除的数）。<ul><li>试除法：通过尝试除以小于等于其平方根的所有整数来判断。（<strong>时间复杂度O(sqrt(n))</strong>）</li><li>埃拉托斯特尼筛法：一种高效的筛选素数的方法。（<strong>时间复杂度O(n log log n)</strong>）</li></ul></li><li>最大公约数与最小公倍数：<ul><li>欧几里得算法：用于计算两个整数的最大公约数。（<strong>时间复杂度O(log(a, b))</strong>）</li></ul></li><li>快速幂：高效计算大整数的幂。（<strong>时间复杂度O(log n)</strong>）</li><li>二进制转换：<ul><li>二进制转十进制</li><li>十进制转二进制</li></ul></li></ul></li><li><strong>数论</strong>：研究整数性质的数学分支。<ul><li>同余问题：<ul><li>线性同余方程：求解形如ax ≡ b (mod m)的方程。</li><li>模运算：求一个数除以另一个数的余数。</li></ul></li><li>数论函数：定义在整数集合上的函数。<ul><li>欧拉函数：计算小于等于n且与n互质的正整数个数。</li><li>莫比乌斯函数：一个数论函数，用于解决一些组合数学问题。</li></ul></li><li>中国剩余定理：求解同余方程组。</li><li>矩阵快速幂：用于快速计算矩阵的幂。</li></ul></li><li><strong>组合数学</strong>：研究组合问题的数学分支。<ul><li>组合数与杨辉三角：<ul><li>组合数：从n个元素中选择k个元素的方案数。</li><li>杨辉三角：一个数表，用于计算组合数。</li></ul></li><li>卡特兰数：一个出现在各种组合问题中的数列。</li></ul></li></ul><h2 id="3-动态规划-dynamic-programming-dp"><a class="markdownIt-Anchor" href="#3-动态规划-dynamic-programming-dp"></a> 3. 动态规划 (Dynamic Programming, DP)</h2><ul><li><strong>经典DP问题</strong>：<ul><li>斐波那契数列：一个递归定义的数列，每个数是前两个数之和。（<strong>时间复杂度O(n)</strong>）</li><li>背包问题：<ul><li>0/1背包：每个物品只能选择一次。（<strong>时间复杂度O(n*capacity)</strong>）</li><li>完全背包：每个物品可以选择多次。（<strong>时间复杂度O(n*capacity)</strong>）</li><li>多重背包：每个物品有有限个。（<strong>时间复杂度O(n_capacity_count)</strong>）</li></ul></li><li>最长公共子序列（LCS）：两个序列的最长公共子序列。（<strong>时间复杂度O(m*n)</strong>）</li><li>最长递增子序列（LIS）：一个序列的最长递增子序列。（<strong>时间复杂度O(n log n)</strong>）</li><li>硬币换零钱问题：用最少的硬币凑出指定金额。（<strong>时间复杂度O(amount*n)</strong>）</li><li>矩阵链乘法：找到矩阵相乘的最佳顺序，使得运算次数最少。（<strong>时间复杂度O(n^3)</strong>）</li></ul></li><li><strong>其他DP问题</strong>：<ul><li>编辑距离问题：将一个字符串转换为另一个字符串所需的最少操作次数。（<strong>时间复杂度O(m*n)</strong>）</li><li>打家劫舍问题：在不能偷窃相邻房屋的情况下，偷窃最多金额。（<strong>时间复杂度O(n)</strong>）</li><li>状态压缩DP：使用位运算来表示状态的动态规划。</li><li>数位DP：用于解决与数字位数有关的动态规划问题。</li></ul></li></ul><h2 id="4-贪心算法"><a class="markdownIt-Anchor" href="#4-贪心算法"></a> 4. 贪心算法</h2><ul><li><strong>经典贪心问题</strong>：<ul><li>活动选择问题：选择最多的不重叠活动。（<strong>时间复杂度O(n log n)</strong>）</li><li>区间调度问题：选择最多的非重叠时间区间。（<strong>时间复杂度O(n log n)</strong>）</li><li>零钱兑换问题：用最少的硬币凑出指定金额。（<strong>不一定能找到最优解</strong>）</li></ul></li><li><strong>其他贪心问题</strong>：<ul><li>最小生成树：找到连接所有顶点的最小权值边的集合。<ul><li>Prim算法（<strong>时间复杂度O(n^2)</strong>）</li><li>Kruskal算法（<strong>时间复杂度O(m log n)</strong>）</li></ul></li><li>霍夫曼编码：用于数据压缩的编码方式。（<strong>时间复杂度O(n log n)</strong>）</li><li>分数背包问题：允许选择物品的一部分。（<strong>时间复杂度O(n log n)</strong>）</li><li>Huffman树：一种用于霍夫曼编码的树结构。</li></ul></li></ul><h2 id="5-回溯法-backtracking"><a class="markdownIt-Anchor" href="#5-回溯法-backtracking"></a> 5. 回溯法 (Backtracking)</h2><ul><li><strong>经典回溯问题</strong>：<ul><li>八皇后问题：在棋盘上放置八个皇后，使其互不攻击。（<strong>时间复杂度较高</strong>）</li><li>N皇后问题：八皇后问题的推广。（<strong>时间复杂度较高</strong>）</li><li>全排列与组合：生成集合的所有排列和组合。（<strong>时间复杂度较高</strong>）</li><li>数独问题：填充数独游戏。（<strong>时间复杂度较高</strong>）</li></ul></li><li><strong>其他回溯问题</strong>：<ul><li>矩阵路径问题：在矩阵中寻找满足条件的路径。（<strong>时间复杂度较高</strong>）</li><li>子集和问题：找到一个集合的子集，其元素之和等于目标值。（<strong>时间复杂度较高</strong>）</li></ul></li></ul><h2 id="6-分治法-divide-and-conquer"><a class="markdownIt-Anchor" href="#6-分治法-divide-and-conquer"></a> 6. 分治法 (Divide and Conquer)</h2><ul><li><strong>经典分治问题</strong>：<ul><li>排序问题：<ul><li>归并排序（<strong>时间复杂度O(n log n)</strong>）</li><li>快速排序（<strong>平均时间复杂度O(n log n)，最坏时间复杂度O(n^2)</strong>）</li></ul></li><li>逆序对计数：计算数组中的逆序对数。（<strong>时间复杂度O(n log n)</strong>）</li><li>最大子数组和问题：找到数组中和最大的连续子数组。（<strong>时间复杂度O(n)</strong>）</li></ul></li><li><strong>其他分治问题</strong>：<ul><li>矩阵乘法：<ul><li>Strassen算法（<strong>时间复杂度O(n^log2(7))</strong>）</li></ul></li></ul></li></ul><h2 id="7-图论-graph-theory"><a class="markdownIt-Anchor" href="#7-图论-graph-theory"></a> 7. 图论 (Graph Theory)</h2><ul><li><strong>图的遍历</strong>：<ul><li>深度优先搜索（DFS）：沿着图的深度方向遍历。（<strong>时间复杂度O(V+E)</strong>）</li><li>广度优先搜索（BFS）：沿着图的宽度方向遍历。（<strong>时间复杂度O(V+E)</strong>）</li></ul></li><li><strong>最短路径问题</strong>：<ul><li>Dijkstra算法：用于计算非负权图的单源最短路径。（<strong>时间复杂度O(E log V)</strong>）</li><li>Bellman-Ford算法：用于计算可以包含负权边的图的单源最短路径。（<strong>时间复杂度O(V*E)</strong>）</li><li>Floyd-Warshall 算法：用于计算任意两点之间的最短路径。（<strong>时间复杂度O(V^3)</strong>）</li></ul></li><li><strong>最小生成树问题</strong>：<ul><li>Prim 算法（<strong>时间复杂度O(E log V)</strong>）</li><li>Kruskal 算法（<strong>时间复杂度O(E log V)</strong>）</li></ul></li><li><strong>其他图论问题</strong>：<ul><li>拓扑排序：对有向无环图进行排序，使得所有边都指向后面的顶点。（<strong>时间复杂度O(V+E)</strong>）</li><li>强连通分量：找到图中互相可达的顶点集合。（<strong>时间复杂度O(V+E)</strong>）</li><li>图的二分性判断：判断一个图是否为二分图。（<strong>时间复杂度O(V+E)</strong>）</li><li>网络流：研究网络中流量的分配问题。</li><li>二分图匹配：找到二分图中最大的匹配数。</li></ul></li></ul><h2 id="8-位运算"><a class="markdownIt-Anchor" href="#8-位运算"></a> 8. 位运算</h2><ul><li><strong>位运算技巧</strong>：直接对二进制位进行操作，效率高。<ul><li>判断是否为 2 的幂：<code>n &amp; (n - 1) == 0</code></li><li>统计二进制中 1 的个数：Hamming Weight</li><li>交换两个数的值：<code>a ^= b; b ^= a; a ^= b;</code></li><li>找出只出现一次的数字：利用异或运算的性质</li><li>计算二进制补码</li></ul></li><li><strong>位运算应用</strong>：<ul><li>状态压缩：用二进制位表示状态</li><li>快速幂：利用位运算优化幂运算</li></ul></li></ul><h2 id="9-树与二叉树"><a class="markdownIt-Anchor" href="#9-树与二叉树"></a> 9. 树与二叉树</h2><ul><li><strong>二叉树的遍历</strong>：<ul><li>前序、中序、后序遍历：递归或迭代方式访问所有节点</li><li>层次遍历：逐层访问节点</li></ul></li><li><strong>二叉树的性质</strong>：<ul><li>判断是否为二叉搜索树：中序遍历结果为升序</li><li>二叉树的最大深度：递归或迭代方式求解</li><li>路径和问题：寻找满足条件的路径</li></ul></li><li><strong>其他树结构</strong>：<ul><li>平衡二叉搜索树：<ul><li>AVL 树：保持左右子树高度差不超过 1</li><li>红黑树：一种自平衡的二叉搜索树</li></ul></li><li>线段树：用于处理区间查询问题</li><li>字典树：用于存储和查找字符串</li></ul></li></ul><h2 id="10-并行与分布式算法"><a class="markdownIt-Anchor" href="#10-并行与分布式算法"></a> 10. 并行与分布式算法</h2><ul><li><strong>并行算法</strong>：利用多核处理器并行计算，提高效率。<ul><li>并行排序问题</li><li>并行搜索问题</li></ul></li><li><strong>分布式算法</strong>：在分布式系统中运行的算法，解决大规模数据处理和存储问题。<ul><li>MapReduce 问题：一种分布式计算框架</li><li>分布式一致性问题：Paxos、Raft 等协议</li></ul></li></ul><h2 id="11-高级数据结构"><a class="markdownIt-Anchor" href="#11-高级数据结构"></a> 11. 高级数据结构</h2><ul><li><strong>平衡树</strong>：<ul><li>AVL 树</li><li>红黑树</li></ul></li><li><strong>其他数据结构</strong>：<ul><li>跳表：一种有序链表，支持快速查找</li><li>并查集（Union-Find）：用于处理集合的合并和查询操作</li><li>LRU 缓存机制：最近最少使用缓存</li><li>堆（优先队列）：一种特殊的树形数据结构，用于快速访问最大/最小值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈集萃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Hello 算法》第二章·算法复杂度</title>
      <link href="/2025/02/01/Hello%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/02/01/Hello%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="hello-算法第二章-算法复杂度"><a class="markdownIt-Anchor" href="#hello-算法第二章-算法复杂度"></a> 《Hello 算法》第二章 · 算法复杂度</h1><p>当我们提到<strong>算法复杂度</strong>时，可以把它当作衡量完成一项任务效率的标准。想象你和朋友一起比赛，看谁能更快地完成整理书架的任务。你们有两种不同的做法，最终谁更快完成任务，谁就是胜利者。通过算法复杂度，我们能够评估不同方法在完成任务时的效率，帮助我们在各种情况下选择最佳的方案。</p><h2 id="时间复杂度任务做得有多快"><a class="markdownIt-Anchor" href="#时间复杂度任务做得有多快"></a> 时间复杂度：任务做得有多快？</h2><p>时间复杂度就像是完成任务所需要的时间。假设你有100本书要整理，每次拿一本书，你都需要检查它放对了没，直到所有书都摆放好了。那么，整理书架的时间就跟书的数量成正比。</p><blockquote><p>在计算机科学中，算法的时间复杂度通过大O符号表示，用来描述算法的运行时间随输入值大小的变化趋势。它通常忽略低阶项和系数，只关注输入规模趋近无穷时的表现。时间复杂度常用来衡量算法在最坏情况下的执行时间，也可用来分析平均情况。通过估算算法操作单元的数量来计算时间复杂度，常见的分类包括线性时间算法（O(n)）和指数时间算法（O(Mn)）。（总结自Wikipedia）</p></blockquote><h3 id="常见的时间复杂度"><a class="markdownIt-Anchor" href="#常见的时间复杂度"></a> 常见的时间复杂度</h3><ul><li><strong>O(1)</strong> — <strong>常数时间复杂度</strong><br />如果不管有多少本书，任务所需时间都一样（比如，找几本书），这就是常数时间复杂度。就像你每次做的动作都很简单，任务的大小对时间没有太大影响。</li><li><strong>O(n)</strong> — <strong>线性时间复杂度</strong><br />假设你是一本一本地整理书，每增加一本书，整理的时间就多一点。这就是线性时间复杂度，任务量增加，所需时间也按比例增加。</li><li><strong>O(n²)</strong> — <strong>平方时间复杂度</strong><br />如果你需要比别人做得更复杂，比如检查每本书与其他每本书的位置是否匹配，时间就会随着任务数量的增加加速增加。每本书要和其他所有书比对一次，这就是平方时间复杂度。</li><li><strong>O(log n)</strong> — <strong>对数时间复杂度</strong><br />这种复杂度表示每次操作都会将问题规模缩小一半，导致时间增长相对较慢。比如，二分查找就是这种算法类型，每次将搜索范围减半，大大提升了效率。</li><li><strong>O(n log n)</strong> — <strong>对数线性时间复杂度</strong><br />这种复杂度常见于高效的排序算法，比如快速排序和归并排序。它的时间复杂度优于O(n²)，但没有O(n)那样直接。</li></ul><h2 id="空间复杂度做任务需要多少空间"><a class="markdownIt-Anchor" href="#空间复杂度做任务需要多少空间"></a> 空间复杂度：做任务需要多少空间？</h2><p>空间复杂度就像是你整理书架时需要的额外空间。假设你有一张大桌子用来暂时放书，那么空间复杂度就是你需要多少桌子来摆放这些书。</p><blockquote><p>在计算机科学中，空间复杂度描述了一个算法或程序执行时所需的存储空间大小，通常以输入值长度为函数。类似于时间复杂度，空间复杂度也使用大O符号表示，如 O(n)、O(n log n)、O(2^n) 等，其中n代表输入长度，影响算法的空间需求。空间复杂度计算时不考虑算法的执行时间。（总结自Wikipedia）</p></blockquote><h3 id="常见的空间复杂度"><a class="markdownIt-Anchor" href="#常见的空间复杂度"></a> 常见的空间复杂度</h3><ul><li><strong>O(1)</strong> — <strong>常数空间复杂度</strong><br />如果你只需要一个小桌子就能完成任务，不管书有多少，空间需求都一样。这就是常数空间复杂度，表示你对空间的需求是固定的，不会随任务大小变化。</li><li><strong>O(n)</strong> — <strong>线性空间复杂度</strong><br />如果你需要一张桌子来放每一本书，那么空间复杂度就是线性的。随着书的增多，你需要的空间也会增加。</li></ul><h3 id="生活中的例子"><a class="markdownIt-Anchor" href="#生活中的例子"></a> 生活中的例子：</h3><ul><li><strong>O(1)</strong>：找固定的物品（比如桌子上的一支笔），不管桌子多大，时间都差不多。</li><li><strong>O(n)</strong>：检查书包里的所有物品，时间随着物品数量的增加而增加。</li><li><strong>O(n²)</strong>：如果你需要检查每两件物品之间的匹配情况，随着物品数量增加，任务变得更加复杂。</li></ul><h2 id="大o符号"><a class="markdownIt-Anchor" href="#大o符号"></a> 大O符号</h2><p>在算法分析中，我们使用大O符号来描述算法的时间或空间复杂度，特别是在最坏情况下。它帮助我们理解数据量增大时，算法性能会如何变化。通过大O符号，我们可以评估不同算法在处理大数据时的效率。</p><blockquote><p>大O符号（Big-O notation）是用来描述算法时间复杂度或空间复杂度的数学符号，表示随着输入数据规模增大，算法的性能或资源需求的增长趋势。大O符号关注的是输入规模趋近无穷时算法的增长速率，忽略常数因子和低阶项，旨在提供算法在最坏情况下的表现。常见的时间复杂度有O(1)（常数时间）、O(n)（线性时间）、O(n²)（平方时间）等，它们帮助我们评估不同算法的效率和适应性，尤其在处理大数据时。（来源：ChatGPT）</p></blockquote><h3 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h3><ul><li><strong>O(1)</strong>：常数时间复杂度，执行时间不随输入规模的变化而变化。</li><li><strong>O(n)</strong>：线性时间复杂度，时间随输入规模成正比增加。</li><li><strong>O(n²)</strong>：平方时间复杂度，时间随输入规模的平方增长，常见于双重循环。</li><li><strong>O(log n)</strong>：对数时间复杂度，时间增长较慢，常用于二分查找、平衡树等算法。</li><li><strong>O(n log n)</strong>：对数线性时间复杂度，通常出现在高效排序算法中，如快速排序、归并排序等。</li></ul><h3 id="空间复杂度分析"><a class="markdownIt-Anchor" href="#空间复杂度分析"></a> 空间复杂度分析</h3><ul><li><strong>O(1)</strong>：常数空间复杂度，额外的空间需求不随输入规模的变化而变化。</li><li><strong>O(n)</strong>：线性空间复杂度，额外空间需求与输入规模成正比。</li></ul><h2 id="总结-共勉"><a class="markdownIt-Anchor" href="#总结-共勉"></a> 总结 &amp; 共勉</h2><p>希望通过这个简洁的介绍，你对算法复杂度有了更加清晰的理解。如果你有任何问题或想深入探讨某个算法复杂度，随时欢迎提问！</p><p>本篇博客是自我学习笔记，如果后续能够有人能够从中汲取到知识和收获，这也是我所希望的。如果有读者不懂或有问题的话，欢迎提出来，让我们一起讨论。同时，我将继续更新算法自学笔记，敬请期待。</p><p>谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P1255 数楼梯</title>
      <link href="/2025/02/01/P1255/"/>
      <url>/2025/02/01/P1255/</url>
      
        <content type="html"><![CDATA[<h1 id="p1255-数楼梯"><a class="markdownIt-Anchor" href="#p1255-数楼梯"></a> P1255 数楼梯</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>楼梯有 N 阶，上楼可以一步上一阶，也可以一步上二阶。<br />编一个程序，计算共有多少种不同的走法。</p><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p>一个数字，楼梯数。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>输出走的方式总数。</p><h3 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h3><h4 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h3><p>对于 60% 的数据，N≤50；<br />对于 100% 的数据，1≤N≤5000。</p><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2><p>我们可以用<strong>递归</strong>角度解决：</p><ol><li>当青蛙跳到<strong>第 n 级楼梯</strong>，可以选择：<ul><li>从第 n-1 级跳到第 n 级（跳 1 级）。</li><li>从第 n-2 级跳到第 n 级（跳 2 级）。</li></ul></li><li>递归关系：<ul><li>f(n)=f(n−1)+f(n−2)<ul><li>其中，f(n) 代表跳到第 n 级楼梯的方法总数。</li><li>并且：<ul><li>如果 n=0，即青蛙在第 0 级楼梯，则 f(0)=0（即什么都不做）。</li><li>如果 n=1，即青蛙跳到第 1 级楼梯，那么只能跳 1 级，则 f(1)=1。</li></ul></li></ul></li></ul></li><li>问题的递归式：<ul><li>基于以上推理，我们可以列出以下递归关系式：</li></ul></li></ol><h2 id="解题"><a class="markdownIt-Anchor" href="#解题"></a> 解题</h2><h3 id="伪代码"><a class="markdownIt-Anchor" href="#伪代码"></a> 伪代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F(n):</span><br><span class="line">    如果 n == 0:</span><br><span class="line">        返回1     // 起始点，不需要跳跃，只有一种方式</span><br><span class="line">    如果 n == 1:</span><br><span class="line">        返回 1    // 只有一种方式跳到第1阶</span><br><span class="line"></span><br><span class="line">    // 从n-1阶跳到n阶，或从n-2阶到n阶</span><br><span class="line">    返回 CountWays(n - 1) + CountWays(n - 2)    </span><br></pre></td></tr></table></figure><p>Python 实现：<br />初版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def F(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return F(n - 1) + F(n - 2)</span><br><span class="line">    </span><br><span class="line">n = input()</span><br><span class="line">print(F(n))</span><br></pre></td></tr></table></figure><p>犯了个低级错误，输入的 n 是字符串。</p><p>改正：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def F(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return F(n - 1) + F(n - 2)</span><br><span class="line">    </span><br><span class="line">n = int(input())</span><br><span class="line">print(F(n))</span><br></pre></td></tr></table></figure><p>OK，提交代码：</p><p>WA、TLE、RE。。。。。。</p><p>应该是效率太低了，难道要用DP解？</p><p>DP（动态规划）</p><ol><li>定义：<ul><li>设 dp[i] 表示青蛙跳到第 n 级台阶的方法数。</li><li>当 i&gt;=2 时，青蛙可以选择：<ul><li>从第 i-1 级楼梯跳到第 n 级。</li><li>从第 i-2 级楼梯跳到第 n 级。</li></ul></li><li>所以，我们可以列出：<ul><li>dp[i]=dp[i−1]+dp[i−2]<ul><li>并且：<ul><li>如果 i=0，dp[0]=1，表示跳到第0阶的方式只有1种（就是不跳）。</li><li>如果 i=1，dp[1]=1，表示跳到第1阶的方式只有1种（就是跳 1 级）。</li></ul></li></ul></li></ul></li></ul></li><li>递推关系：<ul><li>那么，我们很容易得出递推公式：<ul><li>dp[i]=dp[i−1]+dp[i−2]</li></ul></li><li>通过递推公式，从 dp[2] 一直到 dp[n]，逐步计算出结果。</li></ul></li></ol><h2 id="解题dp"><a class="markdownIt-Anchor" href="#解题dp"></a> 解题（DP）</h2><h3 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> Python实现：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def F(n):</span><br><span class="line">    # 如果 n 为 0 或 1，直接返回 1</span><br><span class="line">    if n == 0 or n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    </span><br><span class="line">    # 创建一个 dp 数组，存储每阶的跳法</span><br><span class="line">    dp = [0] * (n + 1)</span><br><span class="line">    </span><br><span class="line">    # 初始条件</span><br><span class="line">    dp[0] = 1  # 第 0 阶只有 1 种方法（不跳）</span><br><span class="line">    dp[1] = 1  # 第 1 阶只有 1 种方法（跳 1 步）</span><br><span class="line">    </span><br><span class="line">    # 递推关系，计算从第 2 阶到第 n 阶的方法数</span><br><span class="line">    for i in range(2, n + 1):</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2]</span><br><span class="line">    </span><br><span class="line">    # 返回跳到第 n 阶的方法数</span><br><span class="line">    return dp[n]</span><br><span class="line"></span><br><span class="line"># 读取输入</span><br><span class="line">n = int(input())</span><br><span class="line">print(F(n))</span><br></pre></td></tr></table></figure><p>提交！<br />AC！<br />完美通过！<br />本篇题解到此结束，</p><h1 id="祝各位读者早日成为神牛牪犇"><a class="markdownIt-Anchor" href="#祝各位读者早日成为神牛牪犇"></a> 祝各位读者早日成为神牛牪犇！</h1>]]></content>
      
      
      <categories>
          
          <category> 解题手记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Hello 算法》第二章·算法复杂度</title>
      <link href="/2025/01/21/Hello%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2025/01/21/Hello%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="hello-算法第一章-初识算法"><a class="markdownIt-Anchor" href="#hello-算法第一章-初识算法"></a> 《Hello 算法》第一章 · 初识算法</h1><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><h3 id="算法定义"><a class="markdownIt-Anchor" href="#算法定义"></a> 算法定义</h3><p><strong>算法</strong>（algorithm）是指在有限时间内通过一组明确的步骤或指令来解决特定问题的过程。它具有以下基本特性：</p><ul><li><strong>明确性</strong>：问题及其输入输出是清晰定义的，确保在不同的执行环境下可以得到一致的结果。</li><li><strong>可行性</strong>：算法能够在有限的步骤、时间和内存空间内完成，保证其可以在实际系统中执行。</li><li><strong>确定性</strong>：每个步骤有清晰的定义，并且在相同的输入和运行条件下，算法的输出始终一致，避免了不确定性和随机性。</li><li><strong>最优性</strong>：在满足问题要求的前提下，算法能够实现最高效的执行，例如最短的时间复杂度和最少的空间消耗。</li></ul><p><strong>实例</strong>：</p><ul><li>排序算法，如冒泡排序（Bubble Sort）和快速排序（Quick Sort），用于将一组无序数据排列为有序数据。快速排序通常被认为是最优的，因为它的平均时间复杂度是 O(n log n)，而冒泡排序的时间复杂度是 O(n²)。</li></ul><h3 id="算法复杂度"><a class="markdownIt-Anchor" href="#算法复杂度"></a> 算法复杂度</h3><p><strong>算法复杂度</strong>（algorithm complexity）是用来衡量算法执行效率的指标，主要包括<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。它反映了算法执行时所需资源的消耗，通常用于评估算法的优劣。</p><ul><li><strong>时间复杂度</strong>：描述算法执行所需时间的增长情况，通常使用大 O 表示法（Big-O notation）。例如，O(n)、O(log n)、O(n²) 等表示算法随着输入规模的增加，运行时间是如何变化的。</li><li><strong>空间复杂度</strong>：描述算法执行时所需内存空间的增长情况。与时间复杂度类似，空间复杂度也可以用大 O 表示法来表示。</li></ul><p><strong>常见的时间复杂度</strong>：</p><ul><li><strong>O(1)</strong>：常数时间复杂度，表示算法的执行时间不随输入规模的增加而变化。</li><li><strong>O(log n)</strong>：对数时间复杂度，表示算法的执行时间随着输入规模的增加而缓慢增长。例如，二分查找算法。</li><li><strong>O(n)</strong>：线性时间复杂度，表示算法的执行时间与输入规模成正比。</li><li><strong>O(n²)</strong>：平方时间复杂度，表示算法的执行时间随着输入规模的平方增长。例如，冒泡排序、插入排序等。</li><li><strong>O(n log n)</strong>：对数线性时间复杂度，表示算法的执行时间比线性增长快，但比平方增长慢。例如，快速排序和归并排序。</li></ul><p><img src="http://49.233.16.143/wp-content/uploads/2025/01/space_complexity_common_types-1024x576.png" alt="space_complexity_common_types" /><br /><img src="http://49.233.16.143/wp-content/uploads/2025/01/time_complexity_common_types-1024x576.png" alt="time_complexity_common_types" /></p><p><strong>这一部分内容将在第二章细讲</strong><br /><strong>实例</strong>：</p><ul><li>在查找某个元素时，线性查找（O(n)）的时间复杂度较高，适用于小规模数据。而二分查找（O(log n)）则适用于已经排序好的数据，效率要高得多。</li></ul><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><h3 id="数据结构定义"><a class="markdownIt-Anchor" href="#数据结构定义"></a> 数据结构定义</h3><p><strong>数据结构</strong>（data structure）是指组织和存储数据的方式，它涉及数据内容、数据间的关系以及对数据的操作方法。良好的数据结构设计能够有效提高程序的性能，达到高效处理数据的目的。数据结构的设计目标包括：</p><ul><li><strong>空间效率</strong>：尽量减少内存占用，节省计算机资源。</li><li><strong>操作效率</strong>：使数据的访问、插入、删除、更新等操作尽可能快速，提升算法的执行效率。</li><li><strong>简洁性</strong>：提供简洁且直观的数据表示和逻辑结构，以便算法能高效运行。</li><li><strong>平衡性</strong>：数据结构的设计是一个权衡过程，为了在某一方面取得优化，往往需要在其他方面做出妥协。例如，哈希表能够提供快速的查找操作，但它的空间消耗可能较大。</li></ul><p><strong>常见的数据结构</strong>：</p><ul><li><strong>线性结构</strong>：如数组、链表、栈、队列。</li><li><strong>树形结构</strong>：如二叉树、平衡二叉树、B 树。</li><li><strong>图形结构</strong>：如无向图、有向图、加权图。</li><li><strong>哈希结构</strong>：哈希表用于快速查找。</li></ul><h3 id="数据结构与算法的关系"><a class="markdownIt-Anchor" href="#数据结构与算法的关系"></a> 数据结构与算法的关系</h3><p>数据结构与算法是紧密相关的，它们的结合体现在以下几个方面：</p><ul><li><strong>数据结构是算法的基础</strong>：数据结构为算法提供了有序的存储结构和方法，通过结构化的存储方式组织数据，并为算法提供快速的访问和修改操作。例如，数组和链表是最常见的数据结构，分别适合不同的算法需求。</li><li><strong>算法为数据结构赋予功能</strong>：数据结构本身仅存储数据，只有与算法结合，才能发挥其应有的作用。通过不同的算法，可以对同一数据结构进行各种操作，如排序、查找、遍历等。</li><li><strong>数据结构的选择影响算法的效率</strong>：同一问题可以通过不同的数据结构来实现，选择合适的数据结构能够显著提高算法的效率。例如，图的遍历可以通过邻接矩阵或邻接表实现，选择不同的数据结构会影响算法的性能。</li></ul><p><img src="https://www.hello-algo.com/chapter_introduction/what_is_dsa.assets/relationship_between_data_structure_and_algorithm.png" alt="relationship_between_data_structure_and_algorithm" /></p><p><strong>实例</strong>：</p><ul><li>在实现图的最短路径算法时，使用邻接矩阵的空间复杂度较高，但适合密集图；而使用邻接表则适用于稀疏图，能够节省内存并提高效率。</li><li>在实现深度优先搜索（DFS）时，栈（Stack）是一个重要的辅助数据结构，它能够帮助我们跟踪节点的遍历路径。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>数据结构与算法是计算机科学的核心，良好的数据结构设计能够帮助我们高效地存储和操作数据，而合理选择和优化算法可以显著提高程序的性能。理解它们之间的关系，能够帮助我们在实际编程中做出更合适的选择，提高代码的执行效率和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习专栏总序</title>
      <link href="/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F%E6%80%BB%E5%BA%8F/"/>
      <url>/2025/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F%E6%80%BB%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="算法自学笔记专栏总序"><a class="markdownIt-Anchor" href="#算法自学笔记专栏总序"></a> 算法自学笔记专栏总序</h1><p>欢迎来到我的《算法自学笔记》专栏！这是我在自学算法过程中的一个学习日志，旨在记录并分享我对常见算法和数据结构的理解、学习过程中的思考以及探索到的有用资源。我希望通过这个专栏，能帮助自己更好地总结学习成果，同时为其他对算法感兴趣的同学提供一些启发和参考。</p><h2 id="专栏内容概览"><a class="markdownIt-Anchor" href="#专栏内容概览"></a> 专栏内容概览</h2><p>本专栏将涵盖以下几个主要方面：</p><ul><li><strong>基本数据结构</strong>：包括数组、链表、栈、队列、哈希表、树、图等常见数据结构。</li><li><strong>排序与查找算法</strong>：涉及快速排序、归并排序、二分查找、线性查找等常用算法。</li><li><strong>动态规划</strong>：深入讲解背包问题、最短路径问题、最长公共子序列等经典问题的解法。</li><li><strong>图算法</strong>：介绍深度优先搜索、广度优先搜索、最小生成树、最短路径等图相关算法。</li><li><strong>其他算法</strong>：包括贪心算法、回溯算法、分治算法等常见的高级算法。</li></ul><h2 id="专栏目标"><a class="markdownIt-Anchor" href="#专栏目标"></a> 专栏目标</h2><ul><li><strong>整理学习笔记</strong>：将学习过程中遇到的关键点、算法实现和常见问题进行总结，并加以归纳整理。</li><li><strong>分享学习经验</strong>：记录并分享自己的自学心得，帮助更多对算法感兴趣的学习者更高效地入门和进阶。</li><li><strong>持续更新</strong>：随着学习的深入，我将持续更新专栏内容，不断补充新的算法和数据结构，力求使本专栏内容更加丰富和完善。</li></ul><h2 id="专栏发展方向"><a class="markdownIt-Anchor" href="#专栏发展方向"></a> 专栏发展方向</h2><p>目前，我已完成了常见数据结构和部分经典算法的学习笔记。未来，我会继续扩展更深入的算法和数据结构内容，并根据实践经验不断优化和完善笔记。</p><p>此外，专栏的配套网站也在开发中，未来将提供更加直观的学习资料，并结合在线编程和算法演示，进一步增强互动性和学习体验。</p><h2 id="如何使用本专栏"><a class="markdownIt-Anchor" href="#如何使用本专栏"></a> 如何使用本专栏</h2><p><a href="https://github.com/LINMOH/self-study-notes-on-algo">仓库地址</a></p><ul><li><strong>浏览笔记</strong>：可以随时浏览并参考专栏中的各类学习笔记，帮助你理解算法的核心思想及其实现方式。</li><li><strong>贡献代码</strong>：如果你在某个算法或数据结构上有新的见解或改进，欢迎通过提交 Pull Request 参与贡献。</li><li><strong>参与讨论</strong>：如果你在学习过程中有问题或想法，可以在 Issues 区域提出，我们一起讨论、解决。</li></ul><h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我"></a> 关于我</h2><h3 id="我的背景"><a class="markdownIt-Anchor" href="#我的背景"></a> 我的背景</h3><p>我是一个初二学生，虽然算法学习起步较晚，但我一直对编程和算法充满浓厚兴趣。如今，我正通过自学不断提升自己的算法水平，并希望能通过实践提升自己的编程能力。</p><h3 id="为什么专注算法学习"><a class="markdownIt-Anchor" href="#为什么专注算法学习"></a> 为什么专注算法学习</h3><p>在我的学习经历中，我曾对编程语言产生浓厚兴趣，并开始尝试学习一些编程语言。然而，老师建议我先专注于算法学习，因为掌握算法的核心思维将帮助我更好地理解编程语言的底层原理。因此，我决定将语言学习暂时搁置，集中精力攻克算法，培养扎实的逻辑思维能力。这一决定，也为我后续的编程之路打下了坚实的基础。</p><h3 id="我的目标"><a class="markdownIt-Anchor" href="#我的目标"></a> 我的目标</h3><p>我的目标是通过不断学习算法和数据结构，在信息奥赛（NOI）中争取获得省赛一等奖。我相信，通过扎实的算法基础，不仅能提升我的编程水平，也能帮助我在将来的编程竞赛中脱颖而出。</p><h2 id="学习资源与参考资料"><a class="markdownIt-Anchor" href="#学习资源与参考资料"></a> 学习资源与参考资料</h2><p>在这条自学算法的道路上，我参考了以下书籍和资料：</p><ul><li>《hello 算法》：为初学者提供了很多实用的算法学习资料和代码示例，帮助我从零基础入门。</li><li>CS自学指南：为自学计算机科学的学生提供了清晰的学习路径，帮助我规划和组织学习内容。</li><li>HackWay技术学习路线：提供了从入门到进阶的技术学习路线，帮助我更系统地提升技能。</li><li>《算法基础：打开算法之门》：为算法入门提供了详细的讲解，帮助我理解基础概念。</li><li>《算法导论》：经典教材，深入探讨了算法设计和分析，是我的重要参考书。</li><li>《数据结构、算法与应用：C<ins>语言描述》：结合C</ins>语言讲解数据结构和算法的实现，帮助我理解实际应用。</li></ul><h2 id="许可证"><a class="markdownIt-Anchor" href="#许可证"></a> 许可证</h2><p>此专栏内容采用 CC BY-NC-SA 4.0 许可证，您可以在非商业用途下使用和分享本专栏的内容，但需要注明出处，并且分享的内容须遵循相同的许可协议。</p><h2 id="致谢"><a class="markdownIt-Anchor" href="#致谢"></a> 致谢</h2><p>特别感谢所有在算法和编程领域做出贡献的前辈，正是因为有了他们的知识和经验，我们这些自学者才能更容易获得进步。希望通过我的努力，这些宝贵的知识能帮助更多的学习者。</p><p>这是我自学算法过程中的一个小小总结和记录，希望你在这个专栏中能收获知识与灵感。欢迎你在学习中提出建议，或者与我共同探讨算法的奥妙！</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技研录,开站!</title>
      <link href="/2025/01/20/%E6%8A%80%E7%A0%94%E5%BD%95-%E5%BC%80%E7%AB%99/"/>
      <url>/2025/01/20/%E6%8A%80%E7%A0%94%E5%BD%95-%E5%BC%80%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="技研录开站"><a class="markdownIt-Anchor" href="#技研录开站"></a> 技研录，开站！</h1><p>我创建这个网站的初衷源于对编程、语言学习和历史的浓厚兴趣。作为一名热衷于探索技术与人文领域的学生，我希望在这片数字空间里记录自己的成长与探索，并通过这个平台展示自己的编程项目和学习成果，同时与志同道合的人分享思考与见解。我的网站将展示我在编程、英语学习、日语以及历史研究等方面的积累与思考。从简单的代码到深刻的思辨，每一项成果都是我成长的一部分。希望你能在这里找到与你志同道合的灵感与启发。</p><p>人生是一段不断挑战自我、追求卓越的旅程。无论是编程的代码，语言的表达，还是历史的学习，每一步都需要耐心与坚持。通过这个平台，我希望与大家共同进步、互相激励。未来的路上，让我们继续学习、探索、不懈追求，成为更好的自己。</p><p>我的未来仍然很长，充满了无限的可能与机会。在这段不断学习与成长的旅程中，我相信每一次努力和突破，都会带来更多选择与机遇。无论是技术创新，还是人生的其他领域，我都愿意保持积极向上的心态，勇敢追逐梦想，迎接新的挑战。未来，我将继续积累经验、拓宽视野，把握每一个机会，成就更好的自己。</p>]]></content>
      
      
      <categories>
          
          <category> 建站日记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
